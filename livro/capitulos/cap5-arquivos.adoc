== Arquivos

:online: {gitrepo}/blob/master/livro/capitulos/code/cap5
:local: code/cap5

.Objetivos do capítulo
____

Ao final deste capítulo você deverá ser capaz de:

* Entender o conceito de arquivos e seus tipos;
* Aprofundar o conhecimento sobre armazenamento e manipulação de dados
  no computador por meio do uso de arquivos;
* Fazer manipulação de dados em arquivos por meio de operações como
  leitura, escrita, dentre outras.  

____


Até agora foi visto como é possível gravar e acessar informações/dados
na memória primária/principal do computador (também chamada memória
RAM). Para isso, foi visto que o uso de ponteiros é fundamental. O
problema dessa abordagem é que as informações/dados de um programa em
C gravadas na memória RAM são perdidas após o término da execução
desse programa. Ou seja, não se pode mais acessá-las ou recuperá-las.
Como fazer para, após a execução de um programa em C, ter acesso a
dados/informações manipuladas nesse programa? Uma solução é gravar
esses dados/informações em um arquivo na memória secundária do
computador (também chamado de Disco Rígido – Hard Disk drive). Nesse
caso, após a execução do programa em C, esses dados/informações
estarão disponíveis no arquivo gravado no disco rígido da máquina.

Nesse capítulo serão abordados conceitos básicos sobre arquivos e
formas de manipulação de dados no disco rígido na linguagem C, como
por exemplo, estratégias para salvar e recuperar dados/informações em
arquivos.

=== Lingua do i

Nós vamos aprender a manipular arquivos em C através da construção de
um pequeno aplicativo que possa ler de um arquivo o texto em português
e convertê-lo para a Língua do i.

A ((*Lingua do i*)) é uma brincadeira infantil que consiste em falar ou
escrever palavras trocando todas as vogais por ``i'':

 Ela ama banana. (em português)
 Ili imi binini. (na língua do i)

=== Etapa 1: Estrutura inicial do projeto

:etapa: etapa1

Vamos começar montando uma estrutura inicial do nosso projeto, que
consistirá em:

.Lista de arquivos do projeto
`lingua-do-i.c`:: Conterá o `main` da aplicação.

`lingua-do-i-core.c`:: Conterá as implementações das principais
funções da aplicação, frequentemente este arquivo será referenciado
apenas como o _core_.  

`lingua-do-i-core.h`:: Conterá as definições das funções de core.

`lingua-do-i-test.c`:: Conterá os testes da aplicação.

`musica-trecho.txt`:: Trecho de música que será utilizado no teste de
leitura de arquivo.  

`Makefile`:: Makefile para compilar o projeto e
executar os testes.

==== Criando um main estúpido

Embora não iremos nos preocupar com o main da aplicação ainda, nosso
primeiro passo será criar o main da aplicação `lingua-do-i` apenas
registrar didaticamente o propósito que este arquivo terá.

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

[source, c]
.Código que contém o main do aplicativo, com implementação estúpida
----
include::{local}/{etapa}/src/lingua-do-i.c[]
----

<1> *Implementação estúpida* para o main da aplicação.
<2> Retorna `EXIT_SUCCESS` indicando que a aplicação saiu sem erros.

NOTE: `EXIT_SUCCESS` é definido em <<stdlib_h>>, junto com
`EXIT_FAILURE` que tem o propósito inverso: indicar que houve erro na
execução da aplicação.

TIP: O termo técnico *((implementação estúpida))* provém do inglês:
*dummy implementation*. Geralmente utilizado quando desejamos aguardar
o momento oportuno para realizar a implementação apropriada, também
costuma ter o propósito de fazer o código compilar ou apenas preencher
algum trecho do código.

Nas próximas seções daremos mais atenção aos testes, enquanto iremos
implementar, aos poucos, as funcionalidades que o aplicativo terá.

Por último, iremos integrar as funcionalidades implementadas ao
aplicativo em `main`.

==== Iniciando um teste

IMPORTANT: Ao decorrer do capítulo iremos escrever vários testes,
este será o primeiro deles. Leia com bastante atenção para perceber
como eles são elaborados.

Decidimos começar os nossos testes tentando ler o conteúdo de um arquivo:

[source,c]
.Elaborando o primeiro teste no arquivo lingua-do-i-test.c
----
#include "lingua-do-i-core.h"

char* NOME_DO_ARQUIVO = "musica-trecho.txt";
char* CONTEUDO_ESPERADO = "Oh! Deus, perdoe este pobre coitado";
void testLerConteudoDoArquivo(){
	char* conteudo = lerConteudoDoArquivo(NOME_DO_ARQUIVO);
	verificaConteudosSaoIguais(conteudo, CONTEUDO_ESPERADO);
}
----

Você é capaz de identificar a ideia da implementação deste teste?
Pense um pouco antes de prosseguir!

.Pontos a serem observados no teste
. O primeiro ponto a ser observado é o nome do teste:
  `testLerConteudoDoArquivo`. O nome de uma função deve ser suficiente
  para descrever qual é o seu propósito. 
. Em seguida, vemos a chamada da função `lerConteudoDoArquivo`, que
  ainda não existe, mas estamos planejando sua implementação. 
  +
  Durante a elaboração dos testes nós escrevemos funções supondo a sua
  existência, mas tarde implementaremos elas. 
  +
  Outro ponto importante, é que estamos definindo qual será interface
  da função `lerConteudoDoArquivo`: (a) ela terá somente um parâmetro
  que será o nome do arquivo que será lido; (b) ela irá retornar um
  ponteiro (`char*`) que conterá o conteúdo lido no arquivo.
. O último comando irá chamar a função `verificaConteudosSaoIguais`,
  que também não foi implementada, mas comunica qual será seu
  propósito: verificar que o conteúdo retornado pela função
  `lerConteudoDoArquivo` corresponde ao conteúdo do arquivo.
. A constante `NOME_DO_ARQUIVO` corresponde ao nome de um
  arquivofootnote:[O arquivo deve existir no mesmo diretório do
  executável] que supostamente possui o mesmo conteúdo da variável
  `CONTEUDO_ESPERADO`. 
  +
  Embora as constantes poderiam ser declaradas dentro das funções, a
  declaração externa possibilita uma maior legibilidade no código do
  teste, mas não há certo ou errado aqui, apenas estilo.
. Um ponto que talvez passe despercebido é a inclusão do arquivo de
  cabeçalho `lingua-do-i-core.h`. Ao fazermos isso, estamos
  antecipando uma dependência que nosso teste terá com
  `lingua-do-i-core.c`. Estamos planejando implementar a função
  `lerConteudoDoArquivo` neste arquivo. 
  +
  Durante o processo de compilação dos testes precisaremos ligar
  (_linkar_) o arquivo de teste com este código fonte. O Makefile do
  projeto deverá refletir esta ligação.

Nosso próximo passo será elaborar o Makefile para que será responsável
pela compilação do projeto.

==== Elaborando o Makefile

Estamos planejando a elaboração de uma aplicação e um teste, portanto
nosso Makefile ficou da seguinte forma:

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

.Makefile do projeto, demonstra como compilar os programas
----
include::{local}/{etapa}/src/Makefile[]
----

NOTE: Este arquivo foi criado para funcionar no Linux, para funcionar
em outras plataformas serão necessários pequenos ajustes.

`CC`:: Indica qual o compilador estamos utilizando. Caso utilize outro,
configure o seu compilador aqui.

`CFLAGS`:: Configura algumas _flags_ de compilação. Inclusive a
utilização do padrão C1X (<<c1x>>). Caso seu compilador aceite estas
_flags_, não haverá necessidade de configuração.

`all`:: Indica quais as regras serão executadas por padrão quando
executamos o comando `make` sem nenhum parâmetro.

`lingua-do-i` e `lingua-do-i-test`:: Regras para construção dos
aplicativos.

`test_all`:: Regra para execução dos testes. Consiste em invocar o
aplicativo de teste.

`clean`:: Regra para apagar os arquivos construídos. A implementação
desta regra consiste em invocar o comando `rm` no Linux, que realiza a
exclusão dos arquivos passados como parâmetros.

Para compilar os aplicativos podemos executar::
+
....
make clean && make all
....

Para compilar e testar os aplicativos podemos executar::
+
....
make clean && make all && make test_all
....

==== Criando um main e compilando o teste

Vamos adicionar um `main` ao nosso arquivo de teste e chamar a função
`testLerConteudoDoArquivo` a partir dele:

[source,c]
.Atualizando lingua-do-i-test.c para invocar o teste
----
#include <stdlib.h>
#include "lingua-do-i-core.h"

char* NOME_DO_ARQUIVO = "musica-trecho.txt";
char* CONTEUDO_ESPERADO = "Oh! Deus, perdoe este pobre coitado";
void testLerConteudoDoArquivo(){
	char* conteudo = lerConteudoDoArquivo(NOME_DO_ARQUIVO);
	verificaConteudosSaoIguais(conteudo, CONTEUDO_ESPERADO);
}

int main(void) {
	testLerConteudoDoArquivo();

	return EXIT_SUCCESS;
}
----

Nós temos algumas funções que ainda não foram escritas, mas vamos
tentar compilar o código mesmo assim, para verificar os erros que
serão apresentados pelo compilador:

.Execução do comando para compilação
....

$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:7:2: aviso: implicit declaration of function ‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:7:19: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
lingua-do-i-test.c:8:2: aviso: implicit declaration of function ‘verificaConteudosSaoIguais’ [-Wimplicit-function-declaration]
/tmp/ccEcEbRI.o: In function `testLerConteudoDoArquivo':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa1/src/lingua-do-i-test.c:7:
undefined reference to `lerConteudoDoArquivo' <1>
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa1/src/lingua-do-i-test.c:8:
undefined reference to `verificaConteudosSaoIguais' <1>
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....
<1> Mensagem informando que não foram encontradas referências às
    funções `lerConteudoDoArquivo` e `verificaConteudosSaoIguais`.

Como esperado, ocorreu erro no processo de compilação devido a
utilização de funções que não foram implementadas ainda.


[TIP]
====
Uma abordagem comum no desenvolvimento utilizando testes é:

. Escrever o teste supondo a existência das funções.
. Fazer o teste compilar utilizando o compilador para determinar o
  próximo ponto que será implementado.
. Fazer o teste falhar.
. Fazer o teste passar.
. Realizar ajustes se necessário.

====

==== Implementando a função verificaConteudosSaoIguais


Nosso próximo passo será a implementação da função que verifica se o
teste irá falha ou não:

[source,c]
.Implementando função verificaConteudosSaoIguais em lingua-do-i-test.c
----
#include <string.h> <1>

...

void verificaConteudosSaoIguais(char* conteudo, char* esperado){
	if(conteudo == NULL){
		exit(EXIT_FAILURE); // não pode ser NULL <2>
	}
	int comparacao = strcmp(conteudo, esperado); // <3>
	if (comparacao!=0){
		exit(EXIT_FAILURE); // strings tem que ser iguais <2>
	};
}
----
<1> Inclusão de `string.h`, que possui várias funções de manipulação
    de strings, inclusive comparação.
<2> Finaliza aplicação indicando que houve um erro.
<3> Executa `strcomp` (definida em <<string_h>>) que compara dois
    strings, retorna `0` somente se ambos os string forem iguais. A
    variável `comparacao` irá guardar o resultado da comparação.

Com a implementação desta função esperamos que o teste falhe caso 
`conteudo` for diferente de `esperado`.  Vamos compilar novamente para
verificar os erros:

.Compilação após implementação da função verificaConteudosSaoIguais
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:18:2: aviso: implicit declaration of function
‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:18:19: aviso: initialization makes pointer from
integer without a cast [habilitado por padrão]
/tmp/ccqV7RJy.o: In function `testLerConteudoDoArquivo':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa1/src/lingua-do-i-test.c:18:
undefined reference to `lerConteudoDoArquivo'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

Ótimo, agora só estamos com um erro, devido a ausência da
implementação de `lerConteudoDoArquivo`.

==== Implementando estúpida de lerConteudoDoArquivo

Vamos adicionar uma implementação estúpida de `lerConteudoDoArquivo`
somente para conseguir compilar o código.

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
.Core do programa, onde as funções serão implementadas
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> Inclusão do arquivo de cabeçalho, onde estarão definidas as funções
    públicas. 
<2> Implementação estúpida da função que desejamos implementar.

Com esta função implementada, vamos tentar compilar novamente:

.Compilação após implementação da função que faltava
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:18:2: aviso: implicit declaration of function ‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:18:19: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
....

Algo estranho aconteceu, apesar de realizar a implementação da última
função que estava faltando. O compilador continua indicando que não
encontrou a função! Por que será?

==== Implementando o cabeçalho de core
Percebemos que ao compilar o arquivo de teste, não foi possível
encontrar a função `lerConteudoDoArquivo` que estava implementada no
arquivo `lingua-do-i-core.c`.

Isto costuma ocorrer pelas seguintes razões:

- A função não existe
- A função existe mas não está visível no processo de compilação
  devido a ligação ou falta de inclusão do arquivo de cabeçalho,
  indicando as definições das funções.

No nosso caso, faltou implementar o arquivo de cabeçalho, que já
estava sendo incluído em ambos os arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

[source, c]
.Cabeçaho do Core
----
include::{local}/{etapa}/src/lingua-do-i-core.h[]
----

<1> Estratégia para definição de cabeçalho que evita erros caso o
    arquivo seja incluído mais de uma vezes. Todos os arquivos de
    cabeçalho da biblioteca padrão de C utiliza esta estratégia.
<2> Definição da função que foi implementada no arquivo `.c`

Vamos compilar novamente!


.Compilando após implementação do cabeçalho
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Ótimo! O arquivo agora está compilando. 

==== Arquivo texto para o teste

Antes de executar o teste, ainda é preciso criar o arquivo de texto
contendo o conteúdo de `CONTEUDO_ESPERADO`. Escolhi uma música de Luiz
Gonzaga, chamada _Súplica Cearense_, e salvei apenas a primeira frase
no arquivo `musica-trecho.txt`.

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Conteúdo do arquivo que está sendo utilizado no testes
----
include::{local}/{etapa}/src/musica-trecho.txt[]
----

O conteúdo deste arquivo contém apenas uma frase, para simplificar a
execução do teste. A ((codificação)) utilizada na escrita do arquivo
foi a UFT-8.

O programa `hexdump`, disponível no Linux, exibe o conteúdo do arquivo
em hexadecimal. Nele você poderá ver como os caracteres estão escritos
no disco:

.Execução do hexdump para verificar conteúdo do arquivo em hexadecimal
----
include::{local}/{etapa}/hexdump-command.txt[]
----

Pela execução do `hexdump`, verificamos que o arquivo possui *0x23
bytes de tamanho* (equivale a `2x16+3=35`), indicado na última linha.

Também podemos perceber que todos os carácteres foram codificados com
1 byte cada (basta contar os carácteres). 

O arquivo não termina com o carácter de fim de linha -- ele finaliza
apenas com o carácter `o`, que tem seu código ASCII igual a `0x6f`. 

TIP: Você pode consultar a tabela ASCII em http://www.asciitable.com,
ou se estiver no Linux através do comando `man ascii`.

IMPORTANT: Ao criar um arquivo de texto para os testes, certifique-se
de conhecer o conteúdo do arquivo criado. As vezes os editores de
texto podem adicionar carácteres de fim de linha que talvez não esteja
visível para você. A execução do `hexdump` é recomendada nestes casos.

==== Verificando o teste falhar

O nosso código já está compilando, agora vamos executar o teste e
verificar o resultado:

.Execução do teste
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
make: ** [test_all] Erro 1
....

Como esperado, nosso teste está falhando. Lembra que nossa função
`lerConteudoDoArquivo` possui uma implementação estúpida? Não há como
passar com uma implementação daquela.

Apesar do erro esperado, a mensagem de erro do teste não foi muito
amigável, indicando apenas que houve `Erro 1`. Vamos corrigir isto na
próxima etapa.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

Certifique-se de ter compreendido esta etapa antes de prosseguir para
a próxima.

=== Etapa 2: Utilizando assert ao invés de exit

:etapa: etapa2

(((assert)))

Na final da etapa anterior vimos que nosso teste não apresentava um
mensagem de erro amigável (informando qual a razão da falha).  Nesta
etapa vamos apenas utilizar a função `assert` ao invés de
`exit(EXIT_FAILURE)`, para mudar isso.

A função `assert`, definida em <<assert_h>>, costuma ser utilizada para
depuração dos programas. Caso a função receba uma expressão com o
valor igual a 0 (zero) causará uma falha na execução da aplicação,
indicando, através de uma mensagem, a linha do código fonte onde a
falha está ocorrendo. 

[[exemplo_assert]]
==== Utilizando assert no teste 
Neste passo incluímos a biblioteca <<assert_h>> e atualizamos a função
`verificaConteudosSaoIguais` para chamar a função `assert`, incluindo
uma mensagem para descrever o erro:

[source,c]
----
#include <assert.h> <1>
// (...)
void verificaConteudosSaoIguais(char* conteudo, char* esperado){
assert(conteudo != NULL && "conteúdo não pode ser NULL"); <2>

assert( strcmp(conteudo, esperado) == 0 <2>
        && "conteúdo deve ser igual ao esperado");
}
----
<1> Inclusão da biblioteca `assert.h`
<2> Atualização das verificações utilizando `assert`

==== Compilação e execução do teste
Vamos compilar e executar o teste, verificando que ele
continuará falhando, mas agora com uma mensagem de erro amigável:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:7: verificaConteudosSaoIguais: Assertion `conteudo != ((void *)0) && "conteúdo não pode ser NULL"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Apesar do teste continuar falhando, agora nós temos certeza do ponto
onde está ocorrendo a falha, sabemos exatamente o arquivo e a linha,
como indicado na mensagem: `lingua-do-i-test.c:7`.

Maravilha! Agora estamos recebendo mensagens mais informativas.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 3: Fazendo o teste passar
:etapa: etapa3

Nesta etapa iremos fazer o teste passar, para garantir que nosso teste
está funcionando corretamente.

Para isso é necessário apenas que nossa função `lerConteudoDoArquivo`
retorne o valor esperado, que corresponde ao conteúdo do arquivo.

==== Implementação para fazer o teste passar

Este passo consiste em realizar as alterações necessárias para o teste
passar.

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
.Core do programa, onde as funções serão implementadas
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> inclusão de variável com o valor esperado
<2> retornando o valor esperado

IMPORTANT: Com esta implementação parece óbvio o teste passará, mas é
importante executá-lo e vê-lo passando, pois as vezes a verificação do
teste está implementada errada, proporcionando conclusões erradas. 

Após as modificações vamos verificar se as funções copiadas realmente
fazem o que se propões a fazer corretamente:

.Compilando e verificando o teste passar
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 4: Lendo do arquivo
:etapa: etapa4

Nesta etapa precisamos implementar a leitura do arquivo e verificar o
teste passando.

TIP: Para verificar como as funções que manipulam arquivos em C são
invocadas para realizar tarefas comuns, recomendo acessar a página
https://gist.github.com/edusantana/8291576 onde estão reunidos
diversos testes demonstrando as funções de manipulação de arquivos.

==== Fornecendo código para leitura de arquivo

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
.Atualização do code com funções para leitura de arquivo
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> Inclusão da biblioteca <<stdbool_h>>, que define o tipo `bool`. Este
    tipo pode ser utilizado como retorno de expressões lógicas. Além
    disso também estão definidos macro `true` com o valor `1` e
    `false` com o valor `0`.
<2> A função `fopen` (<<fopen>>) retorna um ponteiro para `File` se
    conseguir abrir o arquivo, caso contrário retorna `NULL`. Esta
    função tem o propósito de verificar o resultado da chamada àquela
    função.
<3> Para ler o tamanho de um arquivo é necessário ir para o final dele
    e solicitar a posição atual, que corresponde a quantidade de bytes
    que o arquivo possui. Caso o arquivo seja um fluxo (_stream_)
    talvez não seja possível ir *ao final do fluxo*.
<4> Para criar um string com o conteúdo do arquivo, primeiro
    precisamos alocar uma sequência contínua de memória que comporte o
    conteúdo que será lido. Além disso, um string deve terminar com o
    caractér `\0`, para utilização das funções de string. A função
    `calloc` (<<calloc>>), além de alocar espaço na memória,
    inicializa todo o espaço alocado com `0` (zeros). Nem sempre é
    possível alocar espaço para armazenar o espaço do arquivo inteiro,
    caso ele seja grande demais.
<5> Um arquivo para ser lido precisa ser aberto e fechado.

A implementação faz referência a diversas funções que ainda não vimos
como funciona: <<fopen>>, <<fclose>>, <<fread>> e <<fseek>>. Além
disso, os arquivos são referenciados através de um ponteiro para
`FILE` (`File *arquivo`).  

==== Passos de implementação da etapa

Implementando leitura do arquivo::
Neste passo nós copiamos as funções contidas em
https://gist.github.com/edusantana/8291576 que estão relacionadas a
leitura do conteúdo de um arquivo e atualizamos nosso arquivo core.

Compilando e executando o teste::
Após as modificações vamos verificar se as funções copiadas realmente
fazem o que se propões a fazer corretamente:
+
....
include::{local}/{etapa}/make-command.txt[]
....

Nosso teste continua passando! Isto quer dizer que nossa função foi
capaz de ler o conteúdo do arquivo corretamente.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 5: Trocando as vogais do string por i

:etapa: etapa5

Inclusão de teste de tradução::
xx.
+
Compilando para descobrir o próximo passo:
+
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testTraducaoParaLinguaDoI’:
lingua-do-i-test.c:24:2: aviso: implicit declaration of function ‘traduzParaLingaDoI’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:24:28: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
/tmp/ccsT5OZs.o: In function `testTraducaoParaLinguaDoI':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/cap5/etapa5/src/lingua-do-i-test.c:24: undefined reference to `traduzParaLingaDoI'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

Criando função `traduzParaLingaDoI`::
Adição da definição no cabeçalho e implementação estúpida no arquivo
core.
+
Compilando e executando o teste para descobrir o próximo passo:
+
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:8: verificaConteudosSaoIguais: Assertion `conteudo != ((void *)0) && "conteúdo não pode ser NULL"' failed.
Abortado (imagem do núcleo gravada)
....

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 6: Fazendo o teste passar

:etapa: etapa6


==== Fazendo o teste passar
Alteramos a função `traduzParaLingaDoI` para retornar o valor
esperado.

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source,c]
----
char* TRADUCAO="Minhis vigiis, tidi iqui.";
char* traduzParaLingaDoI(char* mensagemOriginal){
	return TRADUCAO;
}
----

.Execução do teste após modificação
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
....

Ótimo, nosso teste está passando! 

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 7: Implementando troca das vogais

:etapa: etapa7

==== Implementando troca das vogais

Inclusão de <<string_h>>, pois vamos usar a função <<strlen>>.

Atualiza `traduzParaLingaDoI` 

[source,c]
----
char* traduzParaLingaDoI(char* mensagemOriginal){ 
	int tamanhoDaMensagem = strlen(mensagemOriginal);
	char* resposta = calloc(1, tamanhoDaMensagem+1);
	for(int i=0; i<tamanhoDaMensagem; i++){
		char caracterDaMensagemOriginal = mensagemOriginal[i];
		resposta[i] = traduzCaracterParaLinguaDoI(
				caracterDaMensagemOriginal);
	}
	return resposta;
}
----


Cria `traduzCaracterParaLinguaDoI`

[source,c]
----
char traduzCaracterParaLinguaDoI(char original){ 
	char resposta;
	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	default:
		resposta = original;
	}
	return resposta;
}
----

.Apesar da nossa implementação o erro continua
....
include::{local}/{etapa}/make-command.txt[]
....

==== Código da etapa

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> Inclusão de `string.h`
<2> Criação de função para traduzir um carácter.
<3> Implementação real da função de traduzir
<4> Optamos por criar uma nova mensagem como resposta, ao invés de
    alterar a mensagem original.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


[[sec_etapa8]]
=== Etapa 8: Depurando a aplicação
:etapa: etapa8

Apesar da nossa simples implementação aparentar está correta, por uma
razão ainda desconhecida o nosso teste está falhando.

Esta é uma boa oportunidade para *((Depurar))* a execução do programa.
A depuração será abordada em um capítulo a parte: <<cap_depuracao>>. O
processo de depuração permite-nos identificar sem precisar alterar o
código inserindo várias mensagens do tipo:

  printf("passou por aqui...")
  printf("O valor de var=%d",var)

TIP: Apesar de não ser um pré-requisito para continuação deste
capítulo, convidamos você a ler o <<cap_depuracao>> antes de
continuar, para conhecer o processo de depuração.

==== Depuração do programa
A depuração do programa pode ser vista na <<sec_depuracao>> e a
identificação do problema na <<sec_depuracao_resultado>>.

==== Correção e verificação do teste passando

Após a correção do código fonte, executamos o teste novamente:

.Re-executando o teste após a correção
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Nosso teste está passando novamente!

[[sec_etapa8_codigo]]
==== Código

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

[source, c]
.Código fonte para os testes
----
include::{local}/{etapa}/src/lingua-do-i-test.c[]
----
<1> Correção realizada

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

[[sec_etapa9]]
=== Etapa 9: Inclusão de novos testes

Após a correção, nossos testes estão passando. Mas será que a
implementação de `traduzParaLingaDoI` está correta?  Vamos adicionar
novos testes para garantir isso.

==== Adição de testes

[source,c]
----
char* MENSAGEM_ORIGINAL2 = "Oh! Deus, será que o senhor se zangou";
char* TRADUCAO_ESPERADA2= "Ih! Diis, sirí qii i sinhir si zingii";
void testTraducaoParaLinguaDoI(){
	char* mensagemTraduzida = traduzParaLingaDoI(MENSAGEM_ORIGINAL);
	verificaConteudosSaoIguais(mensagemTraduzida, TRADUCAO_ESPERADA);
	verificaConteudosSaoIguais(traduzParaLingaDoI(MENSAGEM_ORIGINAL2), TRADUCAO_ESPERADA2);
}
----

==== Execução do teste

.Execução do teste
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

Como a falha ocorreu devido a inclusão do novo teste, isto que dizer
que precisamos atualizar a implementação para fazer o teste passar.

==== Atualizar a implementação para fazer o teste passar

A diferença do teste adicionado é que ele adiciona uma vogal
maiúscula, e outra vogal com acento: *``Oh! Deus, será''*.

Vamos atualizar nossa implementação para possibilitar esta conversão
também:

[source,c]
....
char traduzCaracterParaLinguaDoI(char original){
	char resposta;
	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	case 'A':
	case 'E':
	case 'I':
	case 'O':
	case 'U':
		resposta = 'I'; // <1>
		break;
	case 'á':
	case 'é':
	case 'í':
	case 'ó':
	case 'ú':
		resposta = 'í'; // <2>
		break;
	default:
		resposta = original;
	}
	return resposta;
}
....

<1> Inclusão de conversão de letra maiúscula.
<2> Conversão de caracteres com acentos.

==== Execução dos testes após modificação
.Execução dos testes após modificação
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
lingua-do-i-core.c: Na função ‘traduzCaracterParaLinguaDoI’:
lingua-do-i-core.c:64:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:64:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:65:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:65:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:66:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:66:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:67:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:67:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:68:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:68:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:69:14: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:69:3: aviso: overflow in implicit constant conversion [-Woverflow]
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-core.c: Na função ‘traduzCaracterParaLinguaDoI’:
lingua-do-i-core.c:64:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:64:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:65:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:65:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:66:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:66:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:67:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:67:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:68:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:68:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
lingua-do-i-core.c:69:14: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:69:3: aviso: overflow in implicit constant conversion [-Woverflow]
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Quando executamos o teste, verificamos que o compilador apresentou
vários avisos e o teste falhou.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 10: Tratando texto com acentos

:etapa: etapa10

Na etapa anterior percebemos que a utilização de acentos provocou
falha no nosso teste.

Para compreender o problema precisamos entender sobre
*((codificação))* de arquivos.

Enquanto caracteres ASCII são facilmente codificados, pois cada
carácter possui um único byte (que corresponde ao tamanho de um
`char`), outras codificações, como UTF-8, podem possuir carácteres com
tamanhos diferentes. Alem disso, pode existir mais de uma codificação
para o mesmo carácter.

Por enquanto nós iremos utilizar o ((Algorítmo do Avestruz)) para
resolução de problemas: nós iremos ignorar o problema e continuar
nossa implementação ignorando o tratamento de acentos. Depois, quando
tivermos conhecimento suficiente para tratar este problema poderemos
voltar a ele.

TIP: Você conhecer mais sobre o *Algorítmo do Avestruz* em
http://pt.wikipedia.org/wiki/Algoritmo_do_avestruz.


==== Desfazer teste com acentos
[source,c]
----
char* MENSAGEM_ORIGINAL2="Oh! Deus, será que o senhor se zangou";
char* TRADUCAO_ESPERADA2="Ih! Diis, sirá qii i sinhir si zingii";<1>
----
<1> Substituição do `í` por `á`. Por enquanto nosso programa não irá
    tratar acentos. 

==== Desfazer implementação de core que tratava acentos

[source,c]
----
char traduzCaracterParaLinguaDoI(char original){
	char resposta;

	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	case 'A':
	case 'E':
	case 'I':
	case 'O':
	case 'U':
		resposta = 'I';
		break;
	default:
		resposta = original;
	}

	return resposta;
}
----
==== Re-execução dos testes

.Re-execução dos testes após remoção de tratamento de acentos
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
./lingua-do-i-test
....

==== Criação de arquivo TODO

Criamos um arquivo entitulado `TODO.txt` que manterá registro de
atividades que gostaríamos de realizar no futuro:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/TODO.txt]

[source, c]
.Criação do arquivo TODO.txt
....
include::{local}/{etapa}/TODO.txt[]
....

A criação de um arquivo *TODO* possibilita comunicar para as demais
pessoas (envolvidas ou que irão se envolver no projeto) onde elas
podem contribuir para o projeto.

===== Código do teste
.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-test.c[]
----

===== Código do core
.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 11: Salvando conteúdo em arquivo
:etapa: etapa11

Além de traduzir mensagens nosso programa também precisa salvar seu
conteúdo em arquivo. Nesta etapa vamos atualizar nossa implementação
para possibilitar o salvamento.

==== Adicionar teste de salvamento de conteúdo

Mas uma vez, antes de iniciar a implementação da nossa funcionalidade
iremos escrever um teste para ela.

[source, c]
.Adicionando teste de salvamento de arquivo em lingua-do-i-test.c
----
void verificaConteudoFoiSalvo( FILE* arquivo, 
    char* conteudo_esperado ){
  char* conteudo = lerConteudoDeArquivoArberto(arquivo); <1>
  assert( strcmp(conteudo, conteudo_esperado) == 0
    && "Conteúdo do arquivo não corresponde ao esperado");
}

FILE * criaArquivoTemporario(){
	return tmpfile();
}

char* CONTEUDO_QUALQUER = "abracadabra";
void testSalvaConteudoEmArquivo(){
  FILE * arquivoDestino = criaArquivoTemporario(); <2>
  salvaConteudo(arquivoDestino, CONTEUDO_QUALQUER); <3>
  verificaConteudoFoiSalvo(arquivoDestino, CONTEUDO_QUALQUER); <4>

  fclose(arquivoDestino); <5>
}
----
<1> A função `lerConteudoDeArquivoArberto` foi implementada em
    `lingua-do-i-core.c`, mas ainda não está visível aqui,
    precisaremos adicioná-la ao cabeçalho mais adiante.
<2> Criação de um arquivo temporário para o teste, o conteúdo do teste
    será escrito nele. Se estivéssemos utilizando um arquivo normal,
    deveríamos nos certificar de que o arquivo não existia antes, em
    decorrência de execuções anteriores. Arquivos temporários são bons
    para os testes pois quando fechados são automaticamente excluídos.
<3> Esta função será implementada no core. Percebam que escrevemos a
    função sem passar o nome do arquivo, mas um parâmetro do tipo
    `File*`. Decidimos assim, pois pretendemos salvar o conteúdo
    também na saída padrão (que é do tipo `File*`). 
<4> Função para verificar que o conteúdo escrito no arquivo
    corresponde ao conteúdo passado para a função `salvaConteudo`.
<5> Fechamento do arquivo.


==== Atualização do arquivo de cabeçalho do core
Sabemos que temos algumas alterações pendentes para serem realizadas
no arquivo de cabeçalho do core, vamos realizá-las agora:

[source,c]
.Atualização de lingua-do-i-core.h
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo); <1>
char* lerConteudoDeArquivoArberto(FILE* arquivo); <2>
----
<1> Função que desejamos implementar
<2> Declaração de função já implementada em core mas que não estava
    visível externamente ao arquivo.

==== Implementação vazia para possibilitar teste falhar

Antes de compilar e executar o teste, precisamos ainda criar uma
implementação vazia de `salvaConteudo`:

[source,c]
.Implementação vazia em lingua-do-i-core.c
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo){
}
----

==== Verificando o teste falhando

Com a implementação da função realizada, vamos compilar os arquivos e
executar os testes:

.Compilação e execução dos testes
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:28: verificaConteudoFoiSalvo:
Assertion `strcmp(conteudo, conteudo_esperado) == 0 && "Conteúdo do
arquivo não corresponde ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

Como esperado, o teste falhou pois a função que deveria escrever o
conteúdo está vazia.

==== Fazendo o teste passar

Desta vez não há uma forma simples de fazer o teste passar, precisamos
realmente escrever o conteúdo no arquivo para que o teste passe.

Então implementamos a função `salvaConteudo` da seguinte forma:

[source,c]
.Implementação para escrever conteúdo no arquivo
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo){
  fprintf(arquivoDestino, "%s", conteudo);
}
----

TIP: A função <<fprintf>> é similar a <<printf>>, a única diferença é
que `printf` escreve sempre na saída padrão, enquanto que `fprintf`
recebe como parâmetro qual o arquivo onde será escrito o conteúdo.

.Execução do teste
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Ótimo, nossos testes estão passando novamente!

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 12: Determinando entrada do aplicativo

:etapa: etapa12

Nesta etapa vamos definir como o programa irá determinar qual a
entrada será processada, se utilizará a entrada padrão ou a partir de
um arquivo.

Caso o aplicativo seja invocado sem nenhum parâmetro, ele irá ler da
entrada padrão, caso seja especificado o nome de um arquivo, ele será
utilizado.

==== Testes para especificar a entrada

No código a serguir estão definidos 3 testes, que utilizando os
parâmetros passados pelo sistema operacional à função <<sec_main>>,
tente compreender o significado deles:

[source,c]
.Testes para determinar a entrada do programa
----
int ARGC_SEM_PARAMETROS  = 1;
const char* ARGV_SEM_PARAMETROS[] = {"lingua-do-i"};
void testDefinirEntradaPadrao(){
	FILE* entrada = determinaEntrada(ARGC_SEM_PARAMETROS,
		ARGV_SEM_PARAMETROS);
	verificaEntradaFoiEntradaPadrao(entrada);
}

int ARGC_COM_1_PARAMETRO = 2;
const char* ARGV_ARQUIVO_VALIDO[] =
	{"lingua-do-i", "musica-trecho.txt"};
const char* ARGV_ARQUIVO_INEXISTENTE[] =
	{"lingua-do-i", "inexistente.xyz"};
void testDefinirEntradaDeArquivo(){
	FILE* entrada = determinaEntrada(ARGC_COM_1_PARAMETRO,
		ARGV_ARQUIVO_VALIDO);
	verificaEntradaFoiArquivoValido(entrada);
}

void testDefinirEntradaDeArquivoInexistente(){
	FILE* entrada = determinaEntrada(ARGC_COM_1_PARAMETRO,
		ARGV_ARQUIVO_INEXISTENTE);
	verificaEntradaFoiInvalida(entrada);
}
----

Os três testes estão invocando a função `determinaEntrada`, que ainda
será implementada no core, mas que terá a responsabilidade de
determinar a entrada do aplicativo a partir dos parâmetros passados à
função <<sec_main>>:

testDefinirEntradaPadrao::
Neste teste estamos definindo que se o programa for executado sem
nenhum parâmetro, ele irá ler da entrada padrão.

testDefinirEntradaDeArquivo::
Caso o programa seja invocado passando o nome do arquivo, ele será
utilizado como entrada.

testDefinirEntradaDeArquivoInexistente::
Caso seja passando o nome do arquivo, mas ele não exista, então o
programa não poderá processar a entrada.

TIP: Perceba como os nomes das funções facilitam na compreenção do
código. É preferível que você crie várias funções pequenas com
responsabilidades bem definidas do que uma poucas funções com muitas
responsabilidades.

Por último, também é necessário invocá-los a partir do main:

[source,c]
.Invocando os testes a partir do main
----
int main(void) {
	...
	testDefinirEntradaPadrao();
	testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
----

==== Fazendo os testes falharem

Uma vez definido os testes, nosso próximo passo é fazê-los compilarem
e falharem.

Para fazer os testes compilarem precisamos da ajuda do compilador,
utilizaremos as notificações de problemas de compilação para
descobrir o próximo passo:

.Invocando o compilador para descobrir o próximo passo
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaPadrao’:
lingua-do-i-test.c:54:2: aviso: implicit declaration of function ‘determinaEntrada’ [-Wimplicit-function-declaration]
...
....

O compilador nos informou que a  função `determinaEntrada` ainda não
existe, precisamos defini-la no cabeçalho e criá-la no core:

[source,c]
.Definindo determinaEntrada no cabeçalho
----
FILE* determinaEntrada(int argc, const char* argv[]);
----

[source,c]
.Implementando determinaEntrada no core
----
FILE* determinaEntrada(int argc, const char* argv[]){
	return NULL;
}
----

Vamos invocar a compilação novamente:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaPadrao’:
lingua-do-i-test.c:56:2: aviso: implicit declaration of function ‘verificaEntradaFoiEntradaPadrao’ [-Wimplicit-function-declaration]
...
....

Desobrimos que o próximo passo é criar a função
`verificaEntradaFoiEntradaPadrao`:

[source,c]
----
void verificaEntradaFoiEntradaPadrao(FILE* entrada){
	assert(entrada == stdin && 
	    "Entrada deveria ser Entrada Padrão");
}
----

Compilando para descobrir o próximo passo:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaDeArquivo’:
lingua-do-i-test.c:69:2: aviso: implicit declaration of function ‘verificaEntradaFoiArquivoValido’ [-Wimplicit-function-declaration]
...
....

O erro anterior foi corrigido, agora o compilador nos informa que
precisamos implementar a função `verificaEntradaFoiArquivoValido`:

[source,c]
.Implementação de verificaEntradaFoiArquivoValido no teste
----
void verificaEntradaFoiArquivoValido(FILE* entrada){
	assert(entrada != NULL && entrada!= stdin &&
		"Entrada deveria ser um arquivo válido");
}
----


Mais uma vez, compilando para descobrir o próximo passo:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaDeArquivoInexistente’:
lingua-do-i-test.c:80:2: aviso: implicit declaration of function ‘verificaEntradaFoiInvalida’ [-Wimplicit-function-declaration]
...
....

Novamente, precisamos implementar outra função:

[source,c]
.Implementação da função
----
void verificaEntradaFoiInvalida(FILE* entrada){
	assert(entrada == NULL && "Entrada deve ser inválida");
}
----

.Compilando para descobrir o próximo passo
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:52: verificaEntradaFoiEntradaPadrao: Assertion `entrada == stdin && "Entrada deveria ser Entrada Padrão"' failed.
make: *** [test_all] Abortado (arquivo core criado)
...
....

Ótimo! O código já está compilando e nosso primeiro teste está
falhando. Para verificar os outros testes falhando, basta comentar a
linha de invocação do teste na função `main`:

[source,c]
.Comentando teste para verificar que os demais estão falhando
----
int main(void) {
	testLerConteudoDoArquivo();
	testSalvaConteudoEmArquivo();
	testTraducaoParaLinguaDoI();

	//testDefinirEntradaPadrao();
	testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
----

.Verificando o próximo teste falhando
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:57: verificaEntradaFoiArquivoValido: Assertion `entrada != ((void *)0) && entrada!= stdin && "Entrada deveria ser um arquivo válido"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....


Mais um teste falhando, falta apenas verificar o último.

[source,c]
----
int main(void) {
	testLerConteudoDoArquivo();
	testSalvaConteudoEmArquivo();
	testTraducaoParaLinguaDoI();

	//testDefinirEntradaPadrao();
	//testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
--------

.Tentando verificar o último teste falhando
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

O último teste não está falhando. Verificar que o teste está falhando
é uma etapa muito importantefootnote:[Para saber mais sobre os testes
falhando consulte
http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd.], vamos
modificar a implementação de `determinaEntrada` para garantir isso:

[source,c]
.Modificação em core para todos os testes falharem
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* resultadoParaFalhar;
	if (argc == 1){
		resultadoParaFalhar = stdout;
	}else{
		resultadoParaFalhar = stdin;
	}
	return resultadoParaFalhar;
}
----

Vamos re-executar o teste:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:62: verificaEntradaFoiInvalida: Assertion `entrada == ((void *)0) && "Entrada deve ser inválida"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Após esta modificação todos os testes falham, estamos prontos para
avançar para a próxima etapa.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 13: Fazendo os testes de entrada passarem
:etapa: etapa13


==== Fazendo os testes passarem

Antes de fazer o teste passar, vamos verificar o teste falhando
novamente:

.Verificando teste da entrada padrão falhando
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:53: verificaEntradaFoiEntradaPadrao: Assertion `entrada == stdin && "Entrada deveria ser Entrada Padrão"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Para o teste passar, precisamos retornar `stdin` quando o aplicativo
for invocado sem parâmetros:

[source, c]
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* entrada;
	if (argc == 1){
		entrada = stdin; <1>
	}else{
		entrada = stdin;
	}
	return entrada;
}
----
<1> Quando `argc == 1`, então não há nenhum parâmetro e devemos
    retornar a entrada padrão. 

Vamos executar os testes novamente:

.Re-execução dos testes
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:58: verificaEntradaFoiArquivoValido: Assertion `entrada != ((void *)0) && entrada!= stdin && "Entrada deveria ser um arquivo válido"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Ótimo, nosso primeiro teste passou, e a falha do segundo foi
apresentada. Próximo passo será fazer o segundo teste passar:

[source,c]
.Ajuste para fazer o segundo teste passar
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* entrada;
	if (argc == 1){
		entrada = stdin;
	}else{
		entrada = fopen(argv[1], "r"); <1>
	}
	return entrada;
}
----
<1> Utiliza <<fopen>> para abrir arquivo para leitura, utilizando o
    nome do arquivo passado como parâmetro.

.Re-execução dos testes
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Com esta última modificação todos os nossos testes estão passando! Na
próxima etapa iremos unir a implementação de core no `main()`.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 14: Implementando aplicaçaõ da lingua-do-i
:etapa: etapa14

==== Construindo o main

Agora que já possuímos várias funções implementadas vamos
incorporá-las ao `main` da aplicação.

[source, c]
----
#include <stdio.h>
#include <stdlib.h>
#include "lingua-do-i-core.h" <1>

int main(int argc, const char* argv[]) {<2>

	FILE* entrada = determinaEntrada(argc, argv);

	if (entrada){<3>
		char* conteudo=lerConteudoDeArquivoArberto(entrada);<4>
		char* mensagem = traduzParaLingaDoI(conteudo);<4>
		salvaConteudo(stdout, mensagem);<5>
	}else{
		fprintf(stderr, "Problema ao abrir arquivo: %s\n",
				argv[1]);<6>
		exit(EXIT_FAILURE);<6>
	}

	return EXIT_SUCCESS;
}
----

<1> Nosso primeiro passo é incluir o cabeçalho de core, para poder
    utilizar as funções definidas lá.
<2> Atualizamos o cabeçalho do `main`, adicionando os parâmetros que
    serão atribuídos pelo sistema operacional ao invocar a aplicação.
<3> Em C é comum a checagem de parâmetros desta forma, caso o
    parâmetro seja diferente de zero ou `NULL`, então é um valor válido.
<4> Ler conteúdo da entrada e traduz para língua do i
<5> Salva a mensagem traduzida na saída padrão, o usuário poderá
    redirecionar para um arquivo se desejar.
<6> Caso o arquivo não exista, a aplicação finaliza com mensagem de
    erro.

A seguir você pode conferir a compilação com sucesso da aplicação:

.Compilação de lingua-do-i
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....



==== Executando lingua-do-i

Primeiro vamos testar a tradução lendo de um arquivo passado como
parâmetro:

.Lendo de arquivo passado como parâmetro
....
$ ./lingua-do-i musica-trecho.txt 
Ih! Diis, pirdii isti pibri ciitidi
....

Em seguida, vamos testar ler da entrada padrão, direcionada de um
arquivo:

....
$ ./lingua-do-i < musica-trecho.txt 
Ih! Diis, pirdii isti pibri ciitidi
....

Ainda faltamos testar se foi passado um arquivo que não existe:

....
$ ./lingua-do-i arquivo-que-nao-existe.txt
Problema ao abrir arquivo: arquivo-que-nao-existe.txt
....

Nosso aplicativo foi capaz de ler de um arquivo, passado como
parâmetro ou lendo direcionado pela entrada padrão, mas será que ele é
capaz de ler a partir da entrada padrão sem ser direcionado de um
arquivo? Vamos fazer o teste!

Tentando ler da entrada padrão:
....
$ cat musica-trecho.txt | ./lingua-do-i
....

O resultado esperado não foi satisfatório, ele deveria ser capaz de
ler da entrada padrão, o que está errado com a nossa implementação?

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 15: Processando entrada por fluxo

:etapa: etapa15


==== Incluindo teste para tradução de fluxo

Neste teste, estamos desejando implementar uma função
`traduzFluxoDeEntradaNaSaida` que irá traduzir a mensagem de entrada e
salvar a tradução na saída.  

[source,c]
.Teste de tradução de fluxo
----
char* MUSICA_COMPLETA = "musica-completa.txt";
char* MUSICA_COMPLETA_TRAUDIZADA = "musica-completa-traduzida.txt";
void testTraduzFluxoDeEntrada(){

	FILE* entrada = fopen(MUSICA_COMPLETA,"r");
	FILE* saida = tmpfile();
	traduzFluxoDeEntradaNaSaida(entrada,saida);

	verificaMusicaFoiTraduzidaCorretamenteNaSaida(saida,
			MUSICA_COMPLETA_TRAUDIZADA);

	fclose(entrada);
	fclose(saida);
}
----

Para garantir a tradução correta, criamos um arquivo temporário para
servir como saída da função, em seguida,
`verificaMusicaFoiTraduzidaCorretamenteNaSaida` irá ler o conteúdo
escrito em `saida` e verificar o conteúdo do arquivo
`MUSICA_COMPLETA_TRAUDIZADA`:

[source,c]
----
void verificaMusicaFoiTraduzidaCorretamenteNaSaida(
    FILE* fluxo, char* arquivoComTraducaoCorreta){
  
  rewind(fluxo); // volta para ler do início da saída
  char* conteudo=lerConteudoDeArquivoArberto(fluxo);
  char* traducao=lerConteudoDoArquivo(arquivoComTraducaoCorreta);

  assert( strcmp(conteudo, traducao) == 0
      && "Arquivo deve ser traduzido corretamente");
}
----

==== Salvando a letra da música e sua tradução

.Música completa
....
Oh! Deus, perdoe este pobre coitado
Que de joelhos rezou um bocado
Pedindo pra chuva cair sem parar

(...)

Desculpe eu pedir a toda hora pra chegar o inverno
Desculpe eu pedir para acabar com o inferno
Que sempre queimou o meu Ceará
....

.Música traduzida
....
Ih! Diis, pirdii isti pibri ciitidi
Qii di jiilhis rizii im bicidi
Pidindi pri chivi ciir sim pirir

(...)

Discilpi ii pidir i tidi hiri pri chigir i invirni
Discilpi ii pidir piri icibir cim i infirni
Qii simpri qiiimii i mii Ciirá
....

NOTE: Ainda não estamos tratando vogais acentuadas.

==== Fazendo o teste falhar

.Compilando o código
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testTraduzFluxoDeEntrada’:
lingua-do-i-test.c:107:2: aviso: implicit declaration of function ‘traduzFluxoDeEntradaNaSaida’ [-Wimplicit-function-declaration]
/tmp/ccPNDB7P.o: In function `testTraduzFluxoDeEntrada':
/home/santana/livro/capitulos/code/cap5/etapa15/src/lingua-do-i-test.c:107: undefined reference to `traduzFluxoDeEntradaNaSaida'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

O compilador nos avisou que precisamos criar a função
`traduzFluxoDeEntradaNaSaida`:

[source,c]
.Atualização do cabeçalho
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida);
----

[source,c]
.Criando função vazia no core
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
}
----

.Compilando e executando teste
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:98: verificaMusicaFoiTraduzidaCorretamenteNaSaida: Assertion `strcmp(conteudo, traducao) == 0 && "Arquivo deve ser traduzido corretamente"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Ótimo, nosso teste está falhando!

==== Fazendo o teste passar
Uma vez que nosso teste está falhando, o próximo passo é fazê-lo
passar, com o esforço mínimo. Para isso, vamos atualizar a função
`traduzFluxoDeEntradaNaSaida` para escrever na saída o valor que
esperamos:

[source,c]
.Fazendo o teste passar com esforço mínimo
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
	char* traducao = lerConteudoDoArquivo("musica-completa-traduzida.txt");
	int tamanhoDaTraducao = strlen(traducao);
	fwrite(traducao,1,tamanhoDaTraducao,saida);
}
----

Esta implementação é temporária, servirá apenas para verificarmos o
teste passando:

.Verificação do teste passando
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Ótimo! Nossos testes estão passando novamente. Agora precisamos
substituir a implementação da função por outra que continue passando.

==== Implementando tradução por fluxo

Quando estamos tratando um fluxo, precisamos lê-lo por partes. Só
podemos ler uma outra parte após tratar a anterior. Em nossa
implementação, decidimos dividir o fluxo por linhas:

[source,c]
.Tradução do fluxo por linhas
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
	bool chegouNoFinalDoArquivo = false;

	while (!chegouNoFinalDoArquivo){
		char* linha = lerLinhaDaEntrada(entrada);
		if (tentouLerAposFinalDoArquivo(linha)) {
			chegouNoFinalDoArquivo = true;
		} else {
			char* traducao = traduzParaLingaDoI(linha);
			salvaConteudoNaSaida(traducao, saida);
		}
	}
}
----

A lógica da função `traduzFluxoDeEntradaNaSaida` consiste em ler a
entrada por linhas. A função entra em loop enquanto não chegou ao
final do arquivo: lendo uma linha da entrada por vez, traduz e em
seguida salva a tradução na saída. A condicação de parada do loop
só ocorre quando última linha foi traduzida e o final do arquivo foi
atingido.


A condição de parada é implementada através da variável
`chegouNoFinalDoArquivo`, que inicia com valor `false` e só será
modificada quando `tentouLerAposFinalDoArquivo` retornar verdadeiro.

A função `lerLinhaDaEntrada` será responsável por ler do fluxo de
entrada uma linha linhas. E `salvaConteudoNaSaida` será responsável
por salvar a tradução na saída.

Estas três funções ainda não existem, precisaremos implementá-las a
seguir.

===== Lendo conteúdo da entrada com fgets

Vamos iniciar a implementação com a função `lerLinhaDaEntrada`,
responsável por ler uma linha da entrada:

(((fgets)))(((calloc)))

[source,c]
----
int TAMANHO_MAXIMO_DA_LINHA = 2048; <1>
char* lerLinhaDaEntrada(FILE* entrada){
	char* linha = calloc(1, TAMANHO_MAXIMO_DA_LINHA); <2>
	return fgets(linha, TAMANHO_MAXIMO_DA_LINHA, entrada); <3>
}
----
<1> Definindo tamanho máximo de leitura de linha (buffer).
<2> Alocando espaço suficiente para caber uma linha.
<3> Lendo da entrada e salvando o conteúdo lido no buffer (linha).

Para compreender esta função é preciso entender que <<fgets>> irá ler
até:

1. Encontrar o fim de linha, 
2. Ou até chegar ao final do fluxo 
3. Ou até ler a quantidade de caracteres referenciada por
`TAMANHO_MAXIMO_DA_LINHA`.

[[sec_fgets_feof]]
===== Sobre as funções fgets e feof

O propósito da função <<feof>> é indicar se em leituras anteriores o
final do arquivo foi _atingido_. Para que isto ocorra, as funções de
leitura, como `fgets`, devem registrar na estrutura `FILE` quando
detectarem o final do fluxo.

A função <<fgets>> só poderá indicar que chegou ao final do arquivo
quando ela _atingir_ o final do arquivo. A <<fig_fgets>> ilustra o
funcionamento da função `fgets`, estamos evidenciando dois casos:

Quando última linha não termina com o carácter de final de linha::
Neste caso, os bytes são lidos até quando tentou ler o próximo byte e
identificou que chegou no final do arquivo. Neste momento a função irá
retornar todos os bytes lidos e registrar que o final do arquivo foi
_atingido_. Chamadas subsequentes a `feof` saberão do ocorrido.

Quando a última linha termina com carácter final de linha::
A função `fgets` irá retornar todos os carácteres da última linha,
inclusive o `\n`. Ao encontrar o final de linha, a leitura da linha é
finalizada. Não houve nenhum registo de que se chegou ao final do
arquivo. Somente ao tentar ler mais uma linha, é que a função
`fgets` irá perceber que chegou ao final do arquivo e irá registrar o
ocorrido. Diferente do caso anterior, o retorno da função será `NULL`,
indicando que não houve nenhum conteúdo lido.

[[fig_fgets]]
.Ilustração de leitura com fgets
image::images/cap5/fgets.eps[scaledwidth="80%"]

===== Condição de parada tentouLerAposFinalDoArquivo

Para garantir que todas as linhas lidas sejam traduzidas, não basta
ler até atingir o final do arquivo, precisamos nos certificar que
mesmo atingido o final, a última linha seja traduzida. Portanto, a
condição de parada será ler até que `fgets` retorne null:

[source,c]
----
bool tentouLerAposFinalDoArquivo(char* linha){
	return linha == NULL;
}
----


////
E sobre o tamanho máximo da linha? E se a linha for maior do
que este tamanho máximo? Vamos supor que o tamanho máximo fosse 10
caracteres, e a linha tivesse 15 caracteres. Na primeira chamada a
este método seriam lidos os 10 primeiros caracteres, traduzidos e
processados. A próxima chamada iria ler os caracteres restante até o
final da linha. 
////

===== Salvando o conteúdo com a função fwrite

Finalmente, precisamos salvar o conteúdo traduzido na saída:

[source,c]
.Escrevendo conteúdo na saída
----
void salvaConteudoNaSaida(char* conteudo, FILE* saida){
	int tamanhoDaMensagem = strlen(conteudo);
	fwrite(conteudo,1,tamanhoDaMensagem,saida);
}
----

==== Verificando que os testes continuam passando

Após estas atualizações, vamos verificar se nossos testes continuam
passando:

.Verificando os testes passando após as modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Ótimo, nossos testes estão passando novamente!

==== Atualizando aplicação para processar fluxos

Após os testes passarem, nosso próximo passo será a atualização da
aplicação para utilizar a nova implementação:

[source,c]
.Atualizando main em lingua-do-i.c para processar fluxos
----
int main(int argc, const char* argv[]) {
	FILE* entrada = determinaEntrada(argc, argv);
	if (entrada){
		traduzFluxoDeEntradaNaSaida(entrada, stdout);
	}else{
		fprintf(stderr, "Problema ao abrir arquivo: %s\n",
				argv[1]);
		exit(EXIT_FAILURE);
	}
	return EXIT_SUCCESS;
}
----

Após atualização, vamos compilar a aplicação:

.Compilando a aplicação
....
$ make clean && make lingua-do-i
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
....

Verificando que a aplicação está processando a entrada por fluxo:

.Utilizando aplicação para traduzir fluxo
....
$ cat musica-trecho.txt | ./lingua-do-i
Ih! Diis, pirdii isti pibri ciitidi
....

Ótimo! Nossa aplicação agora é capaz de processar o fluxo de entrada
também.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 16: Tratando acentos

:etapa: etapa16

Revendo nosso arquivo `TODO.txt`, lembramos que ainda está faltando
processar mensagens com acentos.

==== Fazendo o teste de tradução de vogais acentuadas falhar

Nós temos dois testes relacionados à tradução para lingua do i. Por
enquanto eles foram implementados para não traduzirem vogais
acentuadas e estão passando deste jeito. Para fazê-los
falharem nós precisaremos atualizá-los da seguinte forma: 

`testTraducaoParaLinguaDoI`:: Atualizar o string
`TRADUCAO_ESPERADA2`, substituindo `á` por `í`:
+
[source,c]
----
// ANTES
char* TRADUCAO_ESPERADA2= "Ih! Diis, sirá qii i sinhir si zingii";
// DEPOIS
char* TRADUCAO_ESPERADA2= "Ih! Diis, sirí qii i sinhir si zingii";
----

`testTraduzFluxoDeEntrada`:: Neste teste utilizamos o arquivo
`musica-completa-traduzida.txt` que contém o resultado esperado da
tradução. Você pode encontrar o arquivo referido já traduzido na pasta
do código desta etapa: 
{online}/etapa16/src/musica-completa-traduzida.txt 


Após estes modificações, executamos os testes e verificamos que
primeira falha está relacionada ao nosso primeiro teste, devido
a nossa alteração em `TRADUCAO_ESPERADA2`.

.Rexecutando os testes após as modifições com vogais acentuadas
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....


==== Entendendo o que é necessário para fazer o teste passar

Para fazer o teste passar, precisamos transformar ``á'' em ``í''.
Sabemos até agora que estes carácteres são representados com mais de
um byte. Vamos verificar sua representação em decimal:

.Utilizando comando od para ver representação dos caracteres
....
$ echo áéíóú | od -t d1
0000000  -61  -95  -61  -87  -61  -83  -61  -77  -61  -70   10
0000013
....

TIP: O comando `od`, disponível no Linux possui várias opções para
exibição de conteúdos binários. Neste caso estamos utilizando para
imprimir o valor de um byte com sinal, que equivale ao valor de
`signed char`.

Descobrimos que todos estes carácteres possuem dois bytes, onde o
primeiro tem valor `-61` e o segundo depende da vogal utilizada,
confira as representações na tabela a seguir:

[[tab_acento_agudo]]
[options="header",cols="^m,^m,^m"]
.Representação de vogais acentuados em UTF-8
|====
| Carácter | Primeiro Byte | Segundo Byte
| á | -61 | -95
| é | -61 | -87
| í | -61 | -83
| ó | -61 | -77
| ú | -61 | -70
|====

NOTE: O que precisamos fazer é implementar uma tradução que
identifique dois bytes consecutivos desta tabela e escreva na saída os
dois bytes do carácter `í`.

==== Fazendo o primeiro teste de tradução acentuada passar

Decidimos modificar a função `traduzParaLingaDoI`, atualmente
responsável por traduzir uma linha para a língua do i:

[source,c]
----
char* traduzParaLingaDoI(char* mensagemOriginal){
	int tamanhoDaMensagem = strlen(mensagemOriginal);
	char* traducao = calloc(1, tamanhoDaMensagem+1);

	for(int i=0; i<tamanhoDaMensagem; i++){
		char caracterDaMensagemOriginal = mensagemOriginal[i];
		if (podeSerVogalAcentuada(caracterDaMensagemOriginal)){ <1>
			int incremento = traduzCaracteresAcentuados(
					mensagemOriginal,i,traducao);<2>
			i+=incremento;<3>
		}else{ <1>
			traducao[i] = traduzCaracterParaLinguaDoI(<1>
				caracterDaMensagemOriginal);<1>
		}
	}
	return traducao;
}
----
<1> Nossa primeira modificação consiste em verificar se o primeiro
    byte lido corresponde ao início de uma vogal acentuada
    (`podeSerVogalAcentuada`). Se ele *não* for, então seguirá o fluxo
    normal, sendo traduzida pela função que traduz carácteres de um
    byte (`traduzCaracterParaLinguaDoI`), e adicionada ao String que
    corresponde à tradução. *Ainda precisamos criar a função
    `podeSerVogalAcentuada`*.
<2> Caso o primeiro byte lido seja o início de vogal acentuada,
    chamaremos a função `traduzCaracteresAcentuados` que deverá ler os
    bytes restantes necessários para representar o carácter e
    salvá-los na posição indicada por `i` no String `traducao`.
    Teoricamente um carácter acentuado poderia possuir mais de 2
    bytes, portanto esta função precisará retornar um incremento para ser
    utilizado em `i`, para garantir a consistência da posição de
    leitura. *A função `traduzCaracteresAcentuados` ainda não existe*,
    será criada mais adiante.
<3> Atualizamos o valor de `i` com o incremento necessário. É
    importante perceber que no comando `for`, a variável já é
    incrementada (`i++`), portanto não precisamos incrementá-la se
    apenas um byte for lido em `traduzCaracteresAcentuados`.

TIP: Certifique-se de ter entendido o código apresentado antes de
continuar.

Dando sequência, vamos criar as funções que desejamos utilizar,
iniciaremos com `podeSerVogalAcentuada`:

[source,c]
----
bool podeSerVogalAcentuada(char caracterInicial){
	return caracterInicial == -61; <1>
}
----

<1> A implementação desta função é muito simples, conforme resumido na
    <<tab_acento_agudo>>, o primeiro byte de todas as vogais com
    acento agudo tem o valor `-61`. A função simplesmente compara o
    byte lido com este valor, retornando o resultado da comparação.

Em seguida, vamos implementar a última função que ficou faltando:

[source,c]
----
int traduzCaracteresAcentuados(char* mensagem, int i,
		char* traducao){
	int incremento;
	char primeiroByte = mensagem [i];
	char s = mensagem [i+1]; // segundo byte <1>

	assert (primeiroByte == -61); // prefixo dos acentos <2>
	traducao[i] = primeiroByte; // passa o primeiro byte <3>

	if (s==-95 or s==-87 or s==-77 or s==-70){//áéóú <4>
		traducao[i+1] = -83; // í <5>
	}else{
		traducao[i+1] = mensagem[i+1]; <6>
	}
	incremento = 1; <7>
	return incremento;
}
----

<1> Iniciamos a função buscando os valores dos dois primeiros bytes. É
    importante observar aqui os nomes das variáveis. A variável
    `primeiroByte` possui um nome bastante representativo, não há
    necessidade de comentários. Já o segundo byte lido, estamos
    nomeando-o apenas por `s`, para diminuir o tamanho do código. No
    entanto, estamos adicionando um comentário explicando qual o
    propósito desta variável, esta é uma boa prática!
<2> A função `assert` está indicando que o pré-requisito desta função
    é ser chamada quando o primeiro byte possuir o valor `-61`, caso
    contrário seu comportamento não está definido. Aqui o comentário
    mais uma vez é importante, sem ele o número em questão poderia ser
    considerado um Número Mágico.footnote:[Você pode saber mais sobre
    Número Mágico em informática no seguinte link:
    http://pt.wikipedia.org/wiki/Número_mágico_(informática)] Para
    utilização do `assert`, também foi necessário incluir no início do
    código: `#include <assert.h>`.
<3> `traducao[i]` corresponde a posição onde deveremos escrever a
    tradução do carácter lido. Neste trecho, escrevemos o primeiro 
    byte lido na posição correspondente.
<4> Neste `if` estamos comparando o segundo byte lido com o segundo byte
    dos carácteres `áéóú`, conforme indicado no comentário.
<5> Caso o segundo byte lido corresponda ao segundo byte dos
    carácteres indicados, sua tradução corresponderá ao segundo byte
    de `í`, que possui o valor `-83`. Salvamos a tradução na posição
    `traducao[i+1]`.
<6> Caso contrário, o segundo byte é escrito conforme lido. Este é o
    caso inclusive do carácter `í`, que sua tradução corresponde a ele
    mesmo.
<7> Por fim, retornamos `1` como incremento, indicando que só foi
    necessário ler um byte após o primeiro. Também seria possível
    implementar o retorno da seguinte forma: `return 1;`, mas a
    intenção não fica bem transmitida.

Após as alterações em `traduzCaracteresAcentuados`, vamos re-executar
os testes:

.Re-execução dos testes após modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:98: verificaMusicaFoiTraduzidaCorretamenteNaSaida: Assertion `strcmp(conteudo, traducao) == 0 && "Arquivo deve ser traduzido corretamente"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Perceba que a falha agora é outra, nosso primeiro testes passou! A
falha ocorre em `verificaMusicaFoiTraduzidaCorretamenteNaSaida` que
corresponde ao segundo teste, devido as atualizações que
fizemos no arquivo `musica-completa-traduzida.txt`. Isto significa que
nossa implementação conseguiu traduzir corretamente `á` para `í`. Mas
será que ela traduz também `é` para `í`? Nós esperamos que sim, mas
não temos nenhum teste comprovando isso. Vamos fazer isto a seguir.

==== Criando teste de tradução específico para vogais acentuadas

Vamos criar um novo teste com o propósito específico para traduzir
vogais acentuadas:

[source,c]
.Teste específico para vogais acentuadas
----
char* VOGAIS_ACENTUADAS= "áéíóúÁÉÍÓÚ-âêîôûÂÊÎÔÛ-àèìòùÀÈÌÒÙ";
char* ACENTOS_ESPERADOS= "íííííÍÍÍÍÍ-îîîîîÎÎÎÎÎ-ìììììÌÌÌÌÌ";
void testTraduzVogaisAcentuadas(){
	char* traducao = traduzParaLingaDoI(VOGAIS_ACENTUADAS);
	verificaConteudosSaoIguais(traducao, ACENTOS_ESPERADOS);
}
----

O teste é bastante simples, todas as vogais no String
`VOGAIS_ACENTUADAS` deverão ser traduzidas por suas correspondentes em
`ACENTOS_ESPERADOS`. Na última linha verificaremos se os conteúdos são
idênticos.

Um detalhe importante, é que este teste deve ser chamado antes
de `testTraduzFluxoDeEntrada`, que ainda está falhando na tradução da
música:

[source,c]
.Posição da evocação do teste testTraduzFluxoDeEntrada no main
----
int main(void) {
	testLerConteudoDoArquivo();
	testSalvaConteudoEmArquivo();
	testTraducaoParaLinguaDoI();

	testDefinirEntradaPadrao();
	testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	testTraduzVogaisAcentuadas(); <1>
	testTraduzFluxoDeEntrada();

	return EXIT_SUCCESS;
}
----
<1> Precisa ser evocado antes de `testTraduzFluxoDeEntrada`.

Vamos executar os testes novamente, esperamos que a falha seja
diferente da anterior:

....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Ótimo! Como podemos ver, temos uma falha diferente devido a inclusão
do nosso novo teste. O próximo passo será fazer o teste passar.

==== Fazendo o teste específico das vogais acentuadas passar

Nós já temos toda a _infraestrutura_ necessária para tradução das
vogais acentuadas, precisamos apenas descobrir os bytes que
representam todas estas letras e atualizar a função
`traduzCaracteresAcentuados`.

Invocaremos o comando `od` novamente para descobrir os bytes dos
carácteres:

....
$ echo áéíóú ÁÉÍÓÚ âêîôû ÂÊÎÔÛ àèìòù ÀÈÌÒÙ | od -t d1
0000000  -61  -95  -61  -87  -61  -83  -61  -77  -61  -70   32  -61 -127  -61 -119  -61
0000020 -115  -61 -109  -61 -102   32  -61  -94  -61  -86  -61  -82  -61  -76  -61  -69
0000040   32  -61 -126  -61 -118  -61 -114  -61 -108  -61 -101   32  -61  -96  -61  -88
0000060  -61  -84  -61  -78  -61  -71   32  -61 -128  -61 -120  -61 -116  -61 -110  -61
0000100 -103   10
0000102
....

Sabendo que espaço corresponde ao carácter `32`, percebemos que todas
as nossas vogais começam com *o valor do primeiro byte igual a `-61`*.
Vamos construir outra tabela para auxiliar na tradução:

[[tab_vogais_acentuadas]]
[options="header",cols="^m,^m,^m,^m,^m,^m,^m,^m,^m,^m,^m,^m"]
.Representação das vogais acentuadas em UTF-8
|====
| Char | 2º Byte | Char | 2º Byte | Char | 2º Byte | Char | 2º Byte | Char | 2º Byte | Char | 2º Byte
| á | -95 | Á | -127 | â | -94 |Â | -126 |à | -96 |À | -128
| é | -87 | É | -119 | ê | -86 |Ê | -118 |è | -88 |È | -120
| í | -83 | Í | -115 | î | -82 |Î | -114 |ì | -84 |Ì | -116
| ó | -77 | Ó | -109 | ô | -76 |Ô | -108 |ò | -78 |Ò | -110
| ú | -70 | Ú | -102 | û | -69 |Û | -101 |ù | -71 |Ù | -103
|====

A atualização da implementação é trivial, basta comparar o segundo
byte do carácter com os valores da tabela, substituindo-o pelo segundo
byte da vogal i com o acento correspondente:

[source,c]
.Atualizando para tradução dos carácteres acentuados
----
int traduzCaracteresAcentuados(char* mensagem, int i,
		char* traducao){
	int incremento;
	char primeiroByte = mensagem [i];
	char s = mensagem [i+1]; // segundo byte

	assert (primeiroByte == -61); // prefixo dos acentos
	traducao[i] = primeiroByte; // passa o primeiro byte

	if (s==-94 or s==-86 or s==-76 or s==-69){//âêôû
		traducao[i+1] = -82; //î
	}else if (s==-95 or s==-87 or s==-77 or s==-70){//áéóú
		traducao[i+1] = -83; // í
	}else if (s==-96 or s==-88 or s==-78 or s==-71){//àèòù
		traducao[i+1] = -84; //ì
	}else if (s==-126 or s==-118 or s==-108 or s==-101){//ÂÊÔÛ
		traducao[i+1] = -114; //Î
	}else if (s==-127 or s==-119 or s==-109 or s==-102){//ÁÉÓÚ
		traducao[i+1] = -115; //Í
	}else if (s==-128 or s==-120 or s==-110 or s==-103){//ÀÈÒÙ
		traducao[i+1] = -116; //Ì
	}else{
		traducao[i+1] = mensagem[i+1];
	}
	incremento = 1;
	return incremento;
}
----

Após nossas modificações, vamos executar os testes novamente:

.Executando o teste após as modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:98: verificaMusicaFoiTraduzidaCorretamenteNaSaida: Assertion `strcmp(conteudo, traducao) == 0 && "Arquivo deve ser traduzido corretamente"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Estranho! Nosso teste passou e a falha ocorrida foi na função
`verificaMusicaFoiTraduzidaCorretamenteNaSaida`. Mas o estranho é que
teoricamente, uma vez que nossa função de tradução estivesse corretada, ela
deveria traduzir a música também!

==== Fazendo o teste de tradução da música passar com os acentos

A causa da falha é mais fácil de ser encontrada quando sabemos depurar
um programa. Após uma depuração (não mostrada aqui), descobrimos que o
teste falhou pois o programa não conseguiu traduzir `ã` para `ĩ`.

Realmente, nosso programa não estava traduzindo os carácteres com `~`.
Vamos descobrir suas representações:

....
$ echo "ã ~e ĩ õ ũ  Ã ~E Ĩ Õ Ũ" | od -t d1
0000000  -61  -93   32  -31  -70  -67   32  -60  -87   32  -61  -75   32  -59  -87   32
0000020   32  -61 -125   32  -31  -70  -68   32  -60  -88   32  -61 -107   32  -59  -88
0000040   10
....

IMPORTANT: Infelizmente tivemos um problema técnico na impressão do
carácter `e` acentuado com o `~`, estaremos representando o carácter
acentuado através do prefixo `~`. Então `~e` e `~E` representam os
carácteres acentuados em minúsculo e maiúsculo, o equivalente com a
vogal `a` seriam: `ã` e `Ã`.

Desta vez, nos deparamos com uma novidade! Os carácteres `~e` e `~E` são
codificados com 3 bytes e também não começam com `-61`! Vamos
construir nossa tabela para resumir a representação dos carácteres:

.Representação de vogais com `~`
[options="header",cols="^m,^m,^m,^m"]
|====
| Carácter | Bytes       | Carácter | Bytes
| `ã`        | -61 -93     | `Ã` | -61 -125
| `~e`       | -31 -70 -67 | `~E` | -31 -70 -68
| `ĩ`        | -60 -87     | `Ĩ` | -60 -88
| `õ`        | -61 -75     | `Õ` | -61 -107
| `ũ`        | -59 -87     | `Ũ` | -58 -88
|====

Com a tabela em mãos, precisamos atualizar nossa função que detecta
uma possível vogal acentuada:

[source,c ]
.Atualização da detecção do primeiro byte de uma vogal acentuada
----
bool podeSerVogalAcentuada(char caracter) {
	return caracter == -61 or caracter == -31 or caracter == -60
			or caracter == -59;
}
----

Em seguida, atualizamos a regra de tradução na função
`traduzCaracteresAcentuados` da seguinte forma:

[source,c]
.Atualização da função para incluir tradução com tio
----
int traduzCaracteresAcentuados(char* mensagem, int i,
		char* traducao){
	int incremento = 1; // por padrão ler dois bytes
	char primeiroByte = mensagem [i];
	char s = mensagem [i+1]; // segundo byte

	assert (primeiroByte == -61); // prefixo dos acentos
	traducao[i] = primeiroByte; // passa o primeiro byte por padrão

	if (primeiroByte == -61){
		if (s==-94 or s==-86 or s==-76 or s==-69){//âêôû
			traducao[i+1] = -82; //î
		}else if (s==-95 or s==-87 or s==-77 or s==-70){//áéóú
			traducao[i+1] = -83; // í
		}else if (s==-96 or s==-88 or s==-78 or s==-71){//àèòù
			traducao[i+1] = -84; //ì
		}else if (s==-126 or s==-118 or s==-108 or s==-101){//ÂÊÔÛ
			traducao[i+1] = -114; //Î
		}else if (s==-127 or s==-119 or s==-109 or s==-102){//ÁÉÓÚ
			traducao[i+1] = -115; //Í
		}else if (s==-128 or s==-120 or s==-110 or s==-103){//ÀÈÒÙ
			traducao[i+1] = -116; //Ì
		}else if (s==-93 or s==-75){//ãõ
			traducao[i] = -60; //ĩ - substitui primeiro byte
			traducao[i+1] = -87; //ĩ
		}else{
			traducao[i+1] = mensagem[i+1];
		}
	}else if (primeiroByte == -31){
		char terceiro = mensagem[i+2];
		if (s == -70 and terceiro == -67){ // ẽ
			traducao[i] = -60; // ĩ
			traducao[i+1] = -87; // ĩ
			incremento = 2; // descartamos o terceiro byte
		}else{
			traducao[i] = primeiroByte;
			traducao[i+1] = s;
			incremento = 1;
		}
	}else if (primeiroByte == -59){
		if ( s == -87 ) { // ũ
			traducao[i] = -60; // ĩ
			traducao[i+1] = -87; // ĩ
		}else{
			traducao[i] = primeiroByte;
			traducao[i+1] = s;
		}
	}else{
		traducao[i] = primeiroByte;
		traducao[i+1] = s;
	}
	return incremento;
}
----

Nossa implementação ficou grande,footnote:[Alguns estilos de código
defendem que se o código de uma função não couber na tela, ela está
grande demais e deveria delegar responsabilidades para outras
funções.] mas vamos verificar se ela está correta executando os
testes:

.Executando os testes após as modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....


Ótimo! Nossos testes estão passando novamente! Nosso programa está
traduzindo corretamente para língua do i!footnote:[Realmente, um
programa está correto até que alguém encontre um erro ou _bug_.]

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-completa.txt]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-completa-traduzida.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]



=== XXX
* Escrever uma função que seja responsável por ler o conteúdo de um
  arquivo e retornar o conteúdo lido como um string (`char *`).
* Esta função se chamará `lerConteudoDoArquivo` e terá como parâmetro
  o nome do arquivo que desejamos ler (`char* nomeDoArquivo`).
* Esta função será definida no arquivo de cabeçalho
  (`lingua-do-i-core.h`) e implementada no arquivo fonte
  (`lingua-do-i-core.c`).
* Para 


=== Exemplos e diferenças entre Arquivos e Streams

|====
| Exemplo | Tipo | Origem
| Documento do Word | Arquivo | Disco
| Música MP3 | Arquivo | Disco
| Música em rádio on-line | Stream | Placa de Rede
| Vídeo on-line | Stream | Placa de Rede
| Comandos de voz | Stream | Microfone
| Comandos de texto | Stream | Teclado
| Imagem JPG | Arquivo | Discofootnote:[Se a imagem teve origem numa
câmera, você provavelmente copiou a imagem do cartão de memória (que é
um disco).]
| Vídeo de Segurança | Stream | Webcam
|====

Em C Arquivos e Streams (fluxos) são representados da mesma forma,
possuindo uma interface única para processar os dados. No entanto,
eles possuem características diferentes:

|====
| Recurso | Arquivo | Stream/Fluxo
| Podemos ler/escrever bytes/caracteres | Sim | Sim
| Sabemos o seu tamanho antecipadamente | Sim | Não
| São finitos | Sim | Não 
| Seu tamanho pode ser maior do que a RAM do computador | Sim | Sim
| Podemos retroceder ou avançar para ler outra parte | Sim | Não
| A leitura/escrita podem ser realizadas por partes | Sim | Sim
| Origem mais comum | Disco | Dispositivos
|====

=== Pensando sobre a implementação da Língua do i

Vamos pensar um pouco no nosso programa que irá codificar um texto na
Língua do i. 

Qual será a fonte a dados que o programa irá processar?

* Teclado?
* Arquivo pre-fixado como `portugues.txt`?
* Qualquer arquivo solicitado pelo usuário?

[NOTE]
====
A leitura através do *teclado* geralmente consiste em escrever uma
mensagem na tela solicitando o usuário digitar o texto e em seguida
ler o que foi digitado e processar. 

* Digitar um texto grande pode ser tedioso. 
* Como interajo com o programa para informar que ele deve ser finalizado?
  Quando eu digitar a palavra 'Sair' numa linha vazia? Quando não
  digitar nada numa linha vazia?

A leitura através de um *arquivo pré-fixado* pode ser mais simples de
ser implementado, pois provavelmente não há tratamento de configuração
para descobrir qual o arquivo. No entanto, é chato ter sempre que
atualizar um arquivo único para funcionar.

A leitura de qualquer arquivo pode facilitar caso o usuário possua
vários arquivos com conteúdos longos que precisam ser traduzidos.
Provavelmente iremos precisar tratar qual o arquivo será utilizado no
processamento.
====

Como a entrada será processada?

* Ler o conteúdo inteiro e depois processa?
* Ler uma linha por vês e processa?
* Ler um carácter por vez e processa?

[NOTE]
====
Ler o conteúdo inteiro geralmente parece ser a opção mais fácil quando
estamos processando arquivos. No entanto, esta solução pode
inviabilizar o processamento quando a entrada for um fluxo sem fim, ou
até mesmo quando o conteúdo for maior do que a memória do computador.

Ler uma linha por vez pode ser uma solução fácil de implementar, pois
os arquivos de texto são naturalmente divididos em linhas.

Como a tradução para a Língua do i pode ser realizada um carácter por
vez, ela solução também parece viável.
====

Aonde o resultado será apresentado?

* Na tela?
* Em um arquivo fixo como `texto-na-lingua-do-i.txt`?
* Em qualquer arquivo configurado pelo usuário?

[NOTE]
====
A apresentação na tela pode ser uma solução viável caso os conteúdos
a serem traduzidos sejam possuam poucas linhas, caso contrário é
melhor salvar o resultado num arquivo.

Salvar o resultado em um arquivo fixo geralmente não é uma boa
solução, pois não poderíamos processar dois arquivos ao mesmo tempo,
correndo o risco do resultado de um processamento ser sobrescrito pelo
outro.
====

Aonde as mensagens de erros serão apresentadas?

* Na tela?
* Em um arquivo fixo como `erros.txt`?


[NOTE]
====
A primeira vista apresentar os erros na tela parece ser uma boa
solução, no entanto, caso o seu programa esteja rodando em um serviço
num servidor as vezes é mais fácil acessar um arquivo contendo os
erros, pois a ``tela'' do processo talvez esteja indisponível.
====

=== Entrada padrão, saída padrão e saída de erros

Todo programa em C possui automaticamente definido um arquivo para a
entrada padrão, um arquivo para a saída padrão e outro arquivo para
onde a emissão de mensages de erro será direcionada.

Quando vamos executar um programa podemos redirecionar a entrada e as
saídas para outros lugares, no entanto, se não houve nenhuma
configuração o sistema operacional irá configurá-las da seguinte
forma:

.Configuração padrão para as saídas e entradas
|====
| Entrada Padrão | Teclado
| Saída Padrão | Tela
| Saída de Erros | Tela
|====

(((Redirecionar, Entrada Padrão)))

Para redirecinar a Entrada Padrão para um arquivo qualquer basta
executar o programa informando o nome do arquivo da seguinte forma:

 meu-programa < nome-do-arquivo-de-entrada

Para testar a mudança da entrada padrão recomendo a utilização do
aplicativo `sort` (disponível no Linux, OSx e Windows), que realiza
ordenação a partir da entrada padrão.

.caminho do arquivo frutas
....
include::code/cap5/frutas.txt[]
....

 sort < frutas.txt

.Resultado da execução do comando
....
include::code/cap5/frutas-ordenadas.txt[]
....

Além de redirecionar a entrada, nós também podemos redirecionar a
saída para um arquivo da seguinte forma:

 sort < frutas.txt > frutas-ordenadas.txt

Desta forma, o arquivo `frutas-ordenadas.txt` será criado
contendo o mesmo resultado da execução anterior. 

Para demonstrar o redirecionamento da saída de erro vamos utilizar o
comando `mkdir` para tentar criar um diretório que já existe.

 mkdir meudir
 mkdir meudir
 mkdir meudir 2> erros.txt

Na primeira invocação do mkdir o diretório `meu-dir` será criado. Na
segunda invocação, você verá na tela a mensagem de erro relativo a
impossibilidade de criar um diretório que já existe. Na última
execução, as mensagens de erros serão redirecionadas para um arquivo
`erros.txt` que será criado após a execução.

IMPORTANT: Quando os programas vão escrever mensagens devem escolher
cuidadosamente quais as saídas utilizar.

TIP: Para conhecer um pouco mais sobre redirecionamentos consulte:
http://edusantana.github.io/dev/redirecionamentos.html.

=== Decisões sobre a implementação: entrada e saída 

O nosso aplicativo irá *ler o texto da entrada padrão e escrever a
mensagem traduzida na saída padrão*. Caso o usuário deseja traduzir um
arquivo bastará executar a aplicação passando o arquivo pela entrada
padrão. De forma similar, também podemos redirecionar o resultado para
um arquivo se desejar-mos.

.Questões em aberto
* Como a entrada será processada?
** Ler o conteúdo inteiro e depois processa?
** Ler uma linha por vês e processa?
** Ler um carácter por vez e processa?

Para aprender todas as formas de processar a entrada vamos implementar
todas as opções.

=== Lendo o conteúdo inteiro
Ler o conteúdo inteiro antes de processar poderá causa erro de
execução caso o arquivo de entrada seja grande demais.

Durante a implementação precisaremos consultar o tamanho total do
arquivo para poder alocar espaço suficiente para o arquivo. Em
seguida, iremos criar um string contendo todos os caracteres do texto.

Com o string em memória, poderemos processar os caracteres na ordem
que aparecem e trocar as vogais por `i`, imprimindo juntamente os
caracteres restantes que não forem vogais no saída padrão.

=== Lendo uma linha por vez
Para ler uma linha por vez precisamos alocar um espaço suficiente para
salvar uma linha, em seguida preenchê-lo com os caracteres lidos até
encontrar o carácter final de linha, representado por `\n`.

NOTE: Não há problemas em alocar espaço maior do que for utilizado,
contanto que o espaço restante seja inicializado com `\0`, pois a
primeira ocorrência indicará o final de um string, o restante será
ignorado.

=== Lendo um carácter por vez
Ler um carácter por vez não envolve necessidade de alocar espaço na
memória para leitura dos dados.

NOTE: Talvez teremos problemas com codificação do arquivo. Pois
caracteres especiais ocupam mais de um byte quando codificados em
*UTF-8* por exemplo. 


////
Terminando arquivo com linha em branco
////

