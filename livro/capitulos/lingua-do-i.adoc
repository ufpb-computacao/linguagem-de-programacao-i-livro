== Lingua do i

:online: {gitrepo}/blob/master/livro/capitulos/code/lingua-do-i
:local: code/lingua-do-i

.Objetivos do capítulo
____

Ao final deste capítulo você deverá ser capaz de:

* Desenvolver um projeto em C;
* Utilizar testes para guiar a elaboração do projeto;
* Desenvolver uma aplicação que leia e escreva em arquivos;
____


Nós vamos aprender a manipular arquivos em C, através da construção de
um pequeno aplicativo que possa ler de um arquivo o texto em português
e convertê-lo para a Língua do i.

A ((*Lingua do i*)) é uma brincadeira infantil que consiste em falar ou
escrever palavras trocando todas as vogais por ``i'':

 Ela ama banana. (em português)
 Ili imi binini. (na língua do i)

O projeto será desenvolvido em diversas etapas, ao final de cada etapa
você poderá consultar o estado final dos arquivos.

Na primeira etapa iremos criar a estrutura inicial do projeto, o
primeiro teste da aplicação e o Makefile para compilar o projeto.


=== Etapa 1: Estrutura inicial do projeto

:etapa: etapa1

Vamos começar nosso projeto criando uma estrutura inicial do nosso
projeto, que consistirá em:

.Lista de arquivos do projeto
`lingua-do-i.c`:: Conterá o `main` da aplicação.

`lingua-do-i-core.c`:: Conterá as implementações das principais
funções da aplicação, frequentemente este arquivo será referenciado
apenas como o _core_.  

`lingua-do-i-core.h`:: Conterá as definições das funções de core.

`lingua-do-i-test.c`:: Conterá os testes da aplicação.

`musica-trecho.txt`:: Trecho de música que será utilizado no teste de
leitura de arquivo.  

`Makefile`:: Makefile para compilar o projeto e
executar os testes.

==== Criando um main estúpido

Embora não iremos nos preocupar com o main da aplicação ainda, nosso
primeiro passo será criar o main da aplicação `lingua-do-i` apenas
registrar didaticamente o propósito que este arquivo terá.

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

[source, c]
.Código que contém o main do aplicativo, com implementação estúpida
----
include::{local}/{etapa}/src/lingua-do-i.c[]
----

<1> *Implementação estúpida* para o main da aplicação.
<2> Retorna `EXIT_SUCCESS` indicando que a aplicação saiu sem erros.

NOTE: `EXIT_SUCCESS` é definido em <<stdlib_h>>, junto com
`EXIT_FAILURE` que tem o propósito inverso: indicar que houve erro na
execução da aplicação.

TIP: O termo técnico *((implementação estúpida))* provém do inglês:
*dummy implementation*. Geralmente utilizado quando desejamos aguardar
o momento oportuno para realizar a implementação apropriada, também
costuma ter o propósito de fazer o código compilar ou apenas preencher
algum trecho do código.

Nas próximas seções daremos mais atenção aos testes, enquanto iremos
implementar, aos poucos, as funcionalidades que o aplicativo terá.

Por último, iremos integrar as funcionalidades implementadas ao
aplicativo em `main`.

==== Iniciando um teste

IMPORTANT: Ao decorrer do capítulo iremos escrever vários testes,
este será o primeiro deles. Leia com bastante atenção para perceber
como eles são elaborados.

Decidimos começar os nossos testes tentando ler o conteúdo de um
arquivo, o código a seguir foi escrito em `lingua-do-i-test.c`:

[[src_primeiro_teste]]
[source,c]
.Primeiro teste
----
#include "lingua-do-i-core.h"

char* NOME_DO_ARQUIVO = "musica-trecho.txt";
char* CONTEUDO_ESPERADO = "Oh! Deus, perdoe este pobre coitado";
void testLerConteudoDoArquivo(){
	char* conteudo = lerConteudoDoArquivo(NOME_DO_ARQUIVO);
	verificaConteudosSaoIguais(conteudo, CONTEUDO_ESPERADO);
}
----

Você é capaz de identificar a ideia da implementação deste teste?
Pense um pouco antes de prosseguir!

.Pontos a serem observados no teste
. O primeiro ponto a ser observado é o nome do teste:
  `testLerConteudoDoArquivo`. O nome de uma função deve ser suficiente
  para descrever qual é o seu propósito. 
. Em seguida, vemos a chamada da função `lerConteudoDoArquivo`, que
  ainda não existe, mas estamos planejando sua implementação. 
  +
  Durante a elaboração dos testes nós escrevemos funções supondo a sua
  existência, mas tarde implementaremos elas. 
  +
  Outro ponto importante, é que estamos definindo qual será interface
  da função `lerConteudoDoArquivo`: (a) ela terá somente um parâmetro
  que será o nome do arquivo que será lido; (b) ela irá retornar um
  ponteiro (`char*`) que conterá o conteúdo lido no arquivo.
. O último comando irá chamar a função `verificaConteudosSaoIguais`,
  que também não foi implementada, mas comunica qual será seu
  propósito: verificar que o conteúdo retornado pela função
  `lerConteudoDoArquivo` corresponde ao conteúdo do arquivo.
. A constante `NOME_DO_ARQUIVO` corresponde ao nome de um
  arquivofootnote:[O arquivo deve existir no mesmo diretório do
  executável] que supostamente possui o mesmo conteúdo da variável
  `CONTEUDO_ESPERADO`. 
  +
  Embora as constantes poderiam ser declaradas dentro das funções, a
  declaração externa possibilita uma maior legibilidade no código do
  teste, mas não há certo ou errado aqui, apenas estilo.
. Um ponto que talvez passe despercebido é a inclusão do arquivo de
  cabeçalho `lingua-do-i-core.h`. Ao fazermos isso, estamos
  antecipando uma dependência que nosso teste terá com
  `lingua-do-i-core.c`. Estamos planejando implementar a função
  `lerConteudoDoArquivo` neste arquivo. 
  +
  Durante o processo de compilação dos testes precisaremos ligar
  (_linkar_) o arquivo de teste com este código fonte. O Makefile do
  projeto deverá refletir esta ligação.

Nosso próximo passo será elaborar o Makefile para que será responsável
pela compilação do projeto.

==== Elaborando o Makefile

Estamos planejando a elaboração de uma aplicação e um teste, portanto
nosso Makefile ficou da seguinte forma:

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

.Makefile do projeto, demonstra como compilar os programas
----
include::{local}/{etapa}/src/Makefile[]
----

NOTE: Este arquivo foi criado para funcionar no Linux, para funcionar
em outras plataformas serão necessários pequenos ajustes.

`CC`:: Indica qual o compilador estamos utilizando. Caso utilize outro,
configure o seu compilador aqui.

`CFLAGS`:: Configura algumas _flags_ de compilação. Inclusive a
utilização do padrão C1X (<<c1x>>). Caso seu compilador aceite estas
_flags_, não haverá necessidade de configuração.

`all`:: Indica quais as regras serão executadas por padrão quando
executamos o comando `make` sem nenhum parâmetro.

`lingua-do-i` e `lingua-do-i-test`:: Regras para construção dos
aplicativos.

`test_all`:: Regra para execução dos testes. Consiste em invocar o
aplicativo de teste.

`clean`:: Regra para apagar os arquivos construídos. A implementação
desta regra consiste em invocar o comando `rm` no Linux, que realiza a
exclusão dos arquivos passados como parâmetros.

Para compilar os aplicativos podemos executar::
+
....
make clean && make all
....

Para compilar e testar os aplicativos podemos executar::
+
....
make clean && make all && make test_all
....

==== Criando um main e compilando o teste

Vamos adicionar um `main` ao nosso arquivo de teste e chamar a função
`testLerConteudoDoArquivo` a partir dele:

[source,c]
.Atualizando lingua-do-i-test.c para invocar o teste
----
#include <stdlib.h>
#include "lingua-do-i-core.h"

char* NOME_DO_ARQUIVO = "musica-trecho.txt";
char* CONTEUDO_ESPERADO = "Oh! Deus, perdoe este pobre coitado";
void testLerConteudoDoArquivo(){
	char* conteudo = lerConteudoDoArquivo(NOME_DO_ARQUIVO);
	verificaConteudosSaoIguais(conteudo, CONTEUDO_ESPERADO);
}

int main(void) {
	testLerConteudoDoArquivo();

	return EXIT_SUCCESS;
}
----

Nós temos algumas funções que ainda não foram escritas, mas vamos
tentar compilar o código mesmo assim, para verificar os erros que
serão apresentados pelo compilador:

.Execução do comando para compilação
....

$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:7:2: aviso: implicit declaration of function ‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:7:19: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
lingua-do-i-test.c:8:2: aviso: implicit declaration of function ‘verificaConteudosSaoIguais’ [-Wimplicit-function-declaration]
/tmp/ccEcEbRI.o: In function `testLerConteudoDoArquivo':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/lingua-do-i/etapa1/src/lingua-do-i-test.c:7:
undefined reference to `lerConteudoDoArquivo' <1>
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/lingua-do-i/etapa1/src/lingua-do-i-test.c:8:
undefined reference to `verificaConteudosSaoIguais' <1>
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....
<1> Mensagem informando que não foram encontradas referências às
    funções `lerConteudoDoArquivo` e `verificaConteudosSaoIguais`.

Como esperado, ocorreu erro no processo de compilação devido a
utilização de funções que não foram implementadas ainda.


[TIP]
====
Uma abordagem comum no desenvolvimento utilizando testes é:

. Escrever o teste supondo a existência das funções.
. Fazer o teste compilar utilizando o compilador para determinar o
  próximo ponto que será implementado.
. Fazer o teste falhar.
. Fazer o teste passar.
. Realizar ajustes se necessário.

====

==== Implementando a função verificaConteudosSaoIguais


Nosso próximo passo será a implementação da função que verifica se o
teste irá falha ou não:

[source,c]
.Implementando função verificaConteudosSaoIguais em lingua-do-i-test.c
----
#include <string.h> <1>

...

void verificaConteudosSaoIguais(char* conteudo, char* esperado){
	if(conteudo == NULL){
		exit(EXIT_FAILURE); // não pode ser NULL <2>
	}
	int comparacao = strcmp(conteudo, esperado); // <3>
	if (comparacao!=0){
		exit(EXIT_FAILURE); // strings tem que ser iguais <2>
	};
}
----
<1> Inclusão de `string.h`, que possui várias funções de manipulação
    de strings, inclusive comparação.
<2> Finaliza aplicação indicando que houve um erro.
<3> Executa `strcomp` (definida em <<string_h>>) que compara dois
    strings, retorna `0` somente se ambos os string forem iguais. A
    variável `comparacao` irá guardar o resultado da comparação.

Com a implementação desta função esperamos que o teste falhe caso 
`conteudo` for diferente de `esperado`.  Vamos compilar novamente para
verificar os erros:

.Compilação após implementação da função verificaConteudosSaoIguais
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:18:2: aviso: implicit declaration of function
‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:18:19: aviso: initialization makes pointer from
integer without a cast [habilitado por padrão]
/tmp/ccqV7RJy.o: In function `testLerConteudoDoArquivo':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/lingua-do-i/etapa1/src/lingua-do-i-test.c:18:
undefined reference to `lerConteudoDoArquivo'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

Ótimo, agora só estamos com um erro, devido a ausência da
implementação de `lerConteudoDoArquivo`.

==== Implementando estúpida de lerConteudoDoArquivo

Vamos adicionar uma implementação estúpida de `lerConteudoDoArquivo`
somente para conseguir compilar o código.

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
.Core do programa, onde as funções serão implementadas
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> Inclusão do arquivo de cabeçalho, onde estarão definidas as funções
    públicas. 
<2> Implementação estúpida da função que desejamos implementar.

Com esta função implementada, vamos tentar compilar novamente:

.Compilação após implementação da função que faltava
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testLerConteudoDoArquivo’:
lingua-do-i-test.c:18:2: aviso: implicit declaration of function ‘lerConteudoDoArquivo’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:18:19: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
....

Algo estranho aconteceu, apesar de realizar a implementação da última
função que estava faltando. O compilador continua indicando que não
encontrou a função! Por que será?

==== Implementando o cabeçalho de core
Percebemos que ao compilar o arquivo de teste, não foi possível
encontrar a função `lerConteudoDoArquivo` que estava implementada no
arquivo `lingua-do-i-core.c`.

Isto costuma ocorrer pelas seguintes razões:

- A função não existe
- A função existe mas não está visível no processo de compilação
  devido a ligação ou falta de inclusão do arquivo de cabeçalho,
  indicando as definições das funções.

No nosso caso, faltou implementar o arquivo de cabeçalho, que já
estava sendo incluído em ambos os arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

[source, c]
.Cabeçaho do Core
----
include::{local}/{etapa}/src/lingua-do-i-core.h[]
----

<1> Estratégia para definição de cabeçalho que evita erros caso o
    arquivo seja incluído mais de uma vezes. Todos os arquivos de
    cabeçalho da biblioteca padrão de C utiliza esta estratégia.
<2> Definição da função que foi implementada no arquivo `.c`

Vamos compilar novamente!


.Compilando após implementação do cabeçalho
....
$ make clean && make lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Ótimo! O arquivo agora está compilando. 

==== Arquivo texto para o teste

Antes de executar o teste, ainda é preciso criar o arquivo de texto
contendo o conteúdo de `CONTEUDO_ESPERADO`. Escolhi uma música de Luiz
Gonzaga, chamada _Súplica Cearense_, e salvei apenas a primeira frase
no arquivo `musica-trecho.txt`.

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Conteúdo do arquivo que está sendo utilizado no testes
----
include::{local}/{etapa}/src/musica-trecho.txt[]
----

O conteúdo deste arquivo contém apenas uma frase, para simplificar a
execução do teste. A ((codificação)) utilizada na escrita do arquivo
foi a UFT-8.

O programa `hexdump`, disponível no Linux, exibe o conteúdo do arquivo
em hexadecimal. Nele você poderá ver como os caracteres estão escritos
no disco:

.Execução do hexdump para verificar conteúdo do arquivo em hexadecimal
----
include::{local}/{etapa}/hexdump-command.txt[]
----

Pela execução do `hexdump`, verificamos que o arquivo possui *0x23
bytes de tamanho* (equivale a `2x16+3=35`), indicado na última linha.

Também podemos perceber que todos os carácteres foram codificados com
1 byte cada (basta contar os carácteres). 

O arquivo não termina com o carácter de fim de linha -- ele finaliza
apenas com o carácter `o`, que tem seu código ASCII igual a `0x6f`. 

TIP: Você pode consultar a tabela ASCII em http://www.asciitable.com,
ou se estiver no Linux através do comando `man ascii`.

IMPORTANT: Ao criar um arquivo de texto para os testes, certifique-se
de conhecer o conteúdo do arquivo criado. As vezes os editores de
texto podem adicionar carácteres de fim de linha que talvez não esteja
visível para você. A execução do `hexdump` é recomendada nestes casos.

==== Verificando o teste falhar

O nosso código já está compilando, agora vamos executar o teste e
verificar o resultado:

.Execução do teste
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
make: ** [test_all] Erro 1
....

Como esperado, nosso teste está falhando. Lembra que nossa função
`lerConteudoDoArquivo` possui uma implementação estúpida? Não há como
passar com uma implementação daquela.

Apesar do erro esperado, a mensagem de erro do teste não foi muito
amigável, indicando apenas que houve `Erro 1`. Vamos corrigir isto na
próxima etapa.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

Certifique-se de ter compreendido esta etapa antes de prosseguir para
a próxima.

=== Etapa 2: Utilizando assert ao invés de exit

:etapa: etapa2

(((assert)))

Na final da etapa anterior vimos que nosso teste não apresentava um
mensagem de erro amigável (informando qual a razão da falha).  Nesta
etapa vamos apenas utilizar a função `assert` ao invés de
`exit(EXIT_FAILURE)`, para mudar isso.

A função `assert`, definida em <<assert_h>>, costuma ser utilizada para
depuração dos programas. Caso a função receba uma expressão com o
valor igual a 0 (zero) causará uma falha na execução da aplicação,
indicando, através de uma mensagem, a linha do código fonte onde a
falha está ocorrendo. 

[[exemplo_assert]]
==== Utilizando assert no teste 
Neste passo incluímos a biblioteca <<assert_h>> e atualizamos a função
`verificaConteudosSaoIguais` para chamar a função `assert`, incluindo
uma mensagem para descrever o erro:

[source,c]
----
#include <assert.h> <1>
// (...)
void verificaConteudosSaoIguais(char* conteudo, char* esperado){
assert(conteudo != NULL && "conteúdo não pode ser NULL"); <2>

assert( strcmp(conteudo, esperado) == 0 <2>
        && "conteúdo deve ser igual ao esperado");
}
----
<1> Inclusão da biblioteca `assert.h`
<2> Atualização das verificações utilizando `assert`

==== Compilação e execução do teste
Vamos compilar e executar o teste, verificando que ele
continuará falhando, mas agora com uma mensagem de erro amigável:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:7: verificaConteudosSaoIguais: Assertion `conteudo != ((void *)0) && "conteúdo não pode ser NULL"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Apesar do teste continuar falhando, agora nós temos certeza do ponto
onde está ocorrendo a falha, sabemos exatamente o arquivo e a linha,
como indicado na mensagem: `lingua-do-i-test.c:7`.

Maravilha! Agora estamos recebendo mensagens mais informativas.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 3: Fazendo o teste passar
:etapa: etapa3

Nesta etapa iremos fazer o teste passar, para garantir que nosso teste
está funcionando corretamente.

Para isso é necessário apenas que nossa função `lerConteudoDoArquivo`
retorne o valor esperado, que corresponde ao conteúdo do arquivo.

==== Implementação para fazer o teste passar

Este passo consiste em realizar as alterações necessárias para o teste
passar.

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source, c]
.Core do programa, onde as funções serão implementadas
----
include::{local}/{etapa}/src/lingua-do-i-core.c[]
----
<1> inclusão de variável com o valor esperado
<2> retornando o valor esperado

IMPORTANT: Com esta implementação parece óbvio o teste passará, mas é
importante executá-lo e vê-lo passando, pois as vezes a verificação do
teste está implementada errada, proporcionando conclusões erradas. 

Após as modificações vamos verificar se as funções copiadas realmente
fazem o que se propões a fazer corretamente:

.Compilando e verificando o teste passar
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 4: Lendo do arquivo
:etapa: etapa4

Nesta etapa precisamos implementar a leitura do arquivo e verificar o
teste passando.

TIP: No link https://gist.github.com/edusantana/8291576 existem vários
testes com operações em arquivo, você pode utilizá-lo para consultar
como realizar diversas operações, algumas funções deste capítulo estão
disponíveis lá. Este link é um bom recurso de aprendizagem.

===== Abrindo e fechando arquivo para leitura

Antes de iniciar a leitura do conteúdo do arquivos,
é necessário abrir o arquivo para leitura:

[source, c]
----
char* lerConteudoDoArquivo(char* nomeDoArquivo) {
	char* conteudo; <1>

	FILE* arquivo = fopen(nomeDoArquivo, "r"); // <2>
	if (arquivoAbertoComSucesso(arquivo)) { <3>
		conteudo = lerConteudoDeArquivoArberto(arquivo);<4>
		fclose(arquivo); // fecha arquivo <5>
	} else {
		conteudo = NULL;  <6>
	}

	return conteudo; <7>
}
----
<1> Variável `conteudo` irá armazenar o conteúdo do arquivo.
<2> Utilização da função <<fopen>> para abrir o arquivo para leitura.
<3> Função que irá verificar se o arquivo foi aberto com sucesso.
<4> Função que irá ler o conteúdo do arquivo que já foi aberto com
    sucesso.
<5> Todo arquivo que é aberto precisa ser fechado após sua utilização.
<6> Retorna `NULL` em caso de erro na abertura.
<7> Retorna o conteúdo lido ou `NULL` se houve algum erro na abertura
    do arquivo.

Esta função utiliza outras que ainda não foram criadas e
serão apresentadas nas próximas seções: `arquivoAbertoComSucesso` e
`lerConteudoDeArquivoArberto`.

==== Verificando se o arquivo foi aberto com sucesso

Verificar se um arquivo foi aberto com sucesso é muito simples:

[source, c]
.Função pare verificar se arquivo foi aberto com sucesso
----
#include <stdbool.h> <1>
...

bool arquivoAbertoComSucesso(FILE* arquivo) {
  return arquivo != NULL; <2>
}
----
<1> Inclusão da biblioteca <<stdbool_h>>, que define o tipo `bool`. Este
    tipo pode ser utilizado como retorno de expressões lógicas. Além
    disso, na biblioteca também estão definidos macro `true` com o valor `1` e
    `false` com o valor `0`.
<2> A função `fopen` retorna `NULL` caso houve algum erro na abertura
    do arquivo.

Na prática, não há necessidade de utilizar o tipo `bool`, mas esta
solução é mais elegante.

==== Lendo conteúdo do arquivo aberto

Para criar um string com o conteúdo do arquivo, primeiro precisamos
alocar uma sequência contínua de memória que comporte o conteúdo que
será lido. Além disso, devemos alocar um byte a mais pois um string
deve terminar com o carácter `\0`, para utilização das funções de
string. No entanto, nem sempre é possível alocar espaço na memória
para armazenar o conteúdo inteiro do arquivo inteiro.

A função que ler o conteúdo do arquivo foi implementada assim:

[source, c]
----
char* lerConteudoDeArquivoArberto(FILE* arquivo) {
	int tamanhoDoArquivo = lerTamanhoDoArquivo(arquivo);<1>
	char* conteudo = calloc(1, tamanhoDoArquivo+1);<2>

	fread(conteudo, tamanhoDoArquivo, 1, arquivo);<3>

	return conteudo; <4>
}
----
<1> Nesta implementação estamos lendo o conteúdo inteiro do arquivo,
    para isso precisamos saber qual o _tamanho total_ do arquivo. Vamos
    implementar a função `lerTamanhoDoArquivo` que será responsável
    apenas por obter o tamanho do arquivo.
<2> Com o tamanho do arquivo salvo na variável `tamanhoDoArquivo`, será
    necessário alocar (<<calloc>>) o espaço para guardar todo o
    conteúdo do arquivo e mais um byte zero, para indicar o final do
    String.
<3> Com o buffer `conteudo` inicializado com zeros, chamamos a função
    <<fread>> para ler o conteúdo do arquivo e salvá-lo no buffer
    `conteudo`.
<4> Por fim, retornamos o buffer com o conteúdo lido.

As funções devem possuir responsabilidades limitadas, por isso
decidimos delegar a responsabilidade de ler o tamanho do arquivo para
outra função apenas com este propósito: `lerTamanhoDoArquivo`.

==== Descobrindo o tamanho do arquivo

Para ler o tamanho de um arquivo é necessário ir para o final dele e
solicitar a posição atual, que corresponde a quantidade de bytes que o
arquivo possui. Caso o arquivo seja um fluxo (_stream_) talvez não
seja possível ir *ao final do fluxo*.

[[src_funcao_lerTamanhoDoArquivo]]
[source,c]
.Função lerTamanhoDoArquivo
----
/* Efeito colateral: 
Cabeçote de leitura vai para o início do arquivo.*/
int lerTamanhoDoArquivo(FILE* arquivo) {
	fseek(arquivo, 0, SEEK_END); // vai para o final do arquivo
	int tamanho = ftell(arquivo); // pega posição atual (final)

	fseek(arquivo, 0, SEEK_SET); // volta para o início
	return tamanho;i
}
----

Na implementação:

1. Utilizando a função <<fseek>> para mover a cabeça de leitura para o
   final do arquivo. 
2. Em seguida, chamamos a função <<ftell>> para pegar a posição atual de
   leitura do arquivo, que irá corresponder ao tamanho do arquivo.
3. Retornamos para o início do arquivo, para que próximas leituras
   ocorram no início.
4. Retornamos o tamanho do arquivo
5. Registramos como comentário o *Efeito colateral* da função.

==== Executando o teste

Agora que implementamos as funções para leitura, vamos executar o 
teste:

.Executando o teste
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Nosso teste continua passando! Isto quer dizer que nossa função foi
capaz de ler o conteúdo do arquivo corretamente.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 5: Trocando as vogais do string por i

:etapa: etapa5

==== Inclusão de teste de tradução

Vamos iniciar a implementação desta etapa construindo um teste de
tradução, que consistirá em traduzir as vogais para a letra i:

[source,c]
----
char* MENSAGEM_ORIGINAL="Minhas vogais, tudo aqui.";<1>
char* TRADUCAO_ESPERADA="Minhis vigiis, tidi iqui.";<2>
void testTraducaoParaLinguaDoI(){
	char* mensagemTraduzida = traduzParaLingaDoI(MENSAGEM_ORIGINAL);<3>
	verificaConteudosSaoIguais(mensagemTraduzida, TRADUCAO_ESPERADA);<4>
}
----
<1> Mensagem original que será traduzida.
<2> Tradução esperada para a mensagem original.
<3> Invoca função `traduzParaLingaDoI` que deverá traduzir a mensagem
    passada como parâmetro e retornar sua tradução.
<4> Verifica que o resultado da tradução é identico ao esperado
    (`TRADUCAO_ESPERADA`).

Este teste consiste em invocar a função `traduzParaLingaDoI` passando
`MENSAGEM_ORIGINAL` para ser traduzida. 

Com o teste elaborado, vamos invocar o compilador para descobrir o
próximo passo:

.Invocando o compilador para descobrir o próximo passo
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testTraducaoParaLinguaDoI’:
lingua-do-i-test.c:24:2: aviso: implicit declaration of function ‘traduzParaLingaDoI’ [-Wimplicit-function-declaration]
lingua-do-i-test.c:24:28: aviso: initialization makes pointer from integer without a cast [habilitado por padrão]
/tmp/ccsT5OZs.o: In function `testTraducaoParaLinguaDoI':
/home/santana/asciibook/linguagem-de-programacao-i-livro/livro/capitulos/code/lingua-do-i/etapa5/src/lingua-do-i-test.c:24: undefined reference to `traduzParaLingaDoI'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

A função `traduzParaLingaDoI` que utilizamos no teste ainda não
existe, vamo criá-la.

==== Criando a função traduzParaLingaDoI

Primeiro precisaremos atualizar o cabeçalho do core:

[source,c]
.Adicionando função em lingua-do-i-core.h
----
char* traduzParaLingaDoI(char* mensagemOriginal);
----

Em seguida, vamos criar a função com uma implementação estúpida:

[source,c]
.Implementação estúpida de traduzParaLingaDoI em lingua-do-i-core.c
----
char* traduzParaLingaDoI(char* mensagemOriginal){
	return NULL;
}
----

Vamos compilar e executar os nossos testes para descobrir o próximo
passo:

.Compilando e executando os testes:
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:8: verificaConteudosSaoIguais: Assertion `conteudo != ((void *)0) && "conteúdo não pode ser NULL"' failed.
Abortado (imagem do núcleo gravada)
....

Ótimo! O código compilou e estamos com o teste falhando. Nossa próxima
etapa será fazer o teste passar.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 6: Fazendo o teste passar

:etapa: etapa6

O propósito desta etapa é ver o teste passando com o menor esforço
possível.

==== Fazendo o teste passar com esforço mínimo

Como fazer nosso teste passar com o esforço mínimo? Vamos tentar
assim:

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

[source,c]
.Alterando função para retornar resultado esperado
----
char* TRADUCAO="Minhis vigiis, tidi iqui.";
char* traduzParaLingaDoI(char* mensagemOriginal){
	return TRADUCAO;
}
----

Vamos executar novamente os testes para verificar o teste passando:


.Execução dos testes para verificar eles passando
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
....

Ótimo, nosso teste está passando! Na próxima etapa iremos atualizar
nossa implementação.

[NOTE]
====
Talvez você tenha achado esta etapa estranha, e se
perguntando _qual o setindo de uma implementação viciada deste jeito?_

Agora que vimos o teste falhar e passar temos confiança de modificar o
código, enquanto os testes permanecerem passando nossa implementação
estará correta.

====

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 7: Implementando troca das vogais

:etapa: etapa7

Agora que nossos testes estão passando, precisamos fornecer uma outra
implementação de `traduzParaLingaDoI` que seja capaz de traduzir a
mensagem e que mantenha nossos testes passando.

==== Implementando visão geral da tradução

Vamos atualizar a implementação de `traduzParaLingaDoI` para traduzir
a mensagem. A função precisará retornar um novo string, do mesmo
tamanho da mensagem original, copiando os caracteres originais da
mensagem e só traduzindo as vogais para i:

[source,c]
----
char* traduzParaLingaDoI(char* mensagemOriginal){ 
	int tamanhoDaMensagem = strlen(mensagemOriginal);<1>
	char* resposta = calloc(1, tamanhoDaMensagem+1);<2>
	for(int i=0; i<tamanhoDaMensagem; i++){<3>
		char caracterDaMensagemOriginal=mensagemOriginal[i];<3>
		resposta[i] = traduzCaracterParaLinguaDoI(
				caracterDaMensagemOriginal);<4>
	}
	return resposta;<5>
}
----
<1> Consulta o tamanho do string. Para utilização de <<strlen>> é
    necessário incluir <<string_h>> no início do arquivo.
<2> Alocação de espaço para guardar o string do mesmo tamanho da
    mensagem original.
<3> Percorre todos os carácteres de `mensagemOriginal` e salva em
    `caracterDaMensagemOriginal` para ser traduzido.
<4> Chama função `traduzCaracterParaLinguaDoI` para traduzir o
    carácter. Em seguida, salva sua tradução na posição correspondente
    em `resposta`.
<5> Retorna string do mesmo tamanho de `mensagemOriginal` com sua
    tradução.

TIP: Nós poderíamos ter adicionado neste função a lógica de verificar
se o carácter é uma vogal, e só invocar a tradução nestes casos. No
entanto, parecia responsabilidade demais para uma única função,
decidimos atribuí-la a outra função.

NOTE: Outra solução poderia ser alterar diretamente as vogais de
`mensagemOriginal`, o que certamente pouparia espaço para alocação de
memória. Neste caso teríamos que alterar o teste também, pois
`MENSAGEM_ORIGINAL` não mais conteria a mensagem original. 

==== Construindo função para tradução de carácteres

Como vimos anteriormente, vamos construir uma função cujo único
propósito será traduzir vogais para `i` e retornar o valor original
caso o carácter não seja uma vogal:

[source,c]
.Implementando função de tradução de carácteres em lingua-do-i-core.c
----
char traduzCaracterParaLinguaDoI(char original){ 
	char resposta;
	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	default:
		resposta = original;
	}
	return resposta;
}
----

Com nossa implementação super simples, vamos executar nossos testes
com a esperança de que eles estejam passando:


.Execução dos testes após nossa implementação
....
$ make clean && make lingua-do-i-test && ./lingua-do-i-test
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

// O resultado destes testes também é mostrado no capítulo de
// depuração.


Oops! O teste está falhando! Como isto é possível? Nossa implementação
é extremamente simples, ele deveria passar! 

Em casos de erros que não compreendemos a causa, *depurar* o programa
pode ajudar bastante -- é exatamente o que faremos na próxima etapa.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


[[sec_etapa8]]
=== Etapa 8: Depurando a aplicação
:etapa: etapa8

Apesar da nossa simples implementação aparentar está correta, por uma
razão ainda desconhecida o nosso teste está falhando.

Esta é uma boa oportunidade para *((Depurar))* a execução do programa.
A depuração será abordada em um capítulo a parte: <<cap_depuracao>>. O
processo de depuração possibilita evitar alterar o programa incluindo
diversas mensagens com o propósito de compreender a execução do
programa, como estas:

  printf("passou por aqui...")
  printf("O valor de var=%d",var)

TIP: Apesar de não ser um pré-requisito para continuação deste
capítulo, convidamos você a ler o <<cap_depuracao>> antes de
continuar, para conhecer o processo de depuração.

==== Depuração do programa
A depuração do programa pode ser vista na <<sec_depuracao>> e a
identificação do problema na <<sec_depuracao_resultado>>.

[[sec_etapa8_codigo]]
==== Correção realizada

Após a depuração identificamos o problema e corrigimos o erro que
estava em nosso arquivo de teste:

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

[source,c]
.Correção do texto de TRADUCAO_ESPERADA no teste
----
char* TRADUCAO_ESPERADA= "Minhis vigiis, tidi iqii.";
----

Após a correção do código fonte, executamos o teste novamente:

.Re-executando o teste após a correção
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Nosso teste está passando novamente!

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

[[sec_etapa9]]
=== Etapa 9: Inclusão de novos testes

Após a correção, nossos testes estão passando. Mas será que a
implementação de `traduzParaLingaDoI` está correta?  Vamos adicionar
novos testes para garantir isso.

==== Adição de testes

[source,c]
----
char* MENSAGEM_ORIGINAL="Minhas vogais, tudo aqui.";<1>
char* TRADUCAO_ESPERADA="Minhis vigiis, tidi iqii.";<1>
char* MENSAGEM_ORIGINAL2="Oh! Deus, será que o senhor se zangou";<2>
char* TRADUCAO_ESPERADA2="Ih! Diis, sirí qii i sinhir si zingii";<2>
void testTraducaoParaLinguaDoI(){
	char* mensagemTraduzida = traduzParaLingaDoI(MENSAGEM_ORIGINAL);<1>
	verificaConteudosSaoIguais(mensagemTraduzida, TRADUCAO_ESPERADA);<1>
	verificaConteudosSaoIguais(traduzParaLingaDoI(MENSAGEM_ORIGINAL2), TRADUCAO_ESPERADA2);<2>
}
----
<1> Techos já existiam no testes anteriormente.
<2> Techos adicionados ao teste.

Após adicionar mais uma mensagem para ser traduzida, re-executamos os
testes:

.Execução dos testes
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

Como a falha ocorreu devido a inclusão do novo teste, nosso próximo
passo será atualizar a implementação para fazer o teste passar.

==== Atualizar a implementação para fazer o teste passar

A diferença do teste adicionado é que ele adiciona uma vogal
maiúscula(`O`), e outra vogal com acento(`á`): *Oh!* Deus, *será*...

Vamos atualizar nossa implementação para possibilitar esta conversão
também:

[source,c]
....
char traduzCaracterParaLinguaDoI(char original){
	char resposta;
	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	case 'A':
	case 'E':
	case 'I':
	case 'O':
	case 'U':
		resposta = 'I'; // <1>
		break;
	case 'á':
	case 'é':
	case 'í':
	case 'ó':
	case 'ú':
		resposta = 'í'; // <2>
		break;
	default:
		resposta = original;
	}
	return resposta;
}
....

<1> Inclusão de conversão de letra maiúscula.
<2> Conversão de caracteres com acentos.

Após estas modificações vamos compilar e executar os testes novamente:

.Compilação e execução dos testes após modificações
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
lingua-do-i-core.c: Na função ‘traduzCaracterParaLinguaDoI’:
lingua-do-i-core.c:64:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:64:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
...
lingua-do-i-core.c:69:14: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:69:3: aviso: overflow in implicit constant conversion [-Woverflow]
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-core.c: Na função ‘traduzCaracterParaLinguaDoI’:
lingua-do-i-core.c:64:7: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:64:2: aviso: case label value exceeds maximum value for type [habilitado por padrão]
...
lingua-do-i-core.c:69:14: aviso: constante de caractere multi-caractere [-Wmultichar]
lingua-do-i-core.c:69:3: aviso: overflow in implicit constant conversion [-Woverflow]
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Quando executamos o teste, verificamos que o compilador apresentou
vários alertas e o teste falhou. A falha provavelmente está
relacionada aos acentos, vamos compreender melhor na próxima etapa.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 10: Tratando texto com acentos

:etapa: etapa10

Na etapa anterior percebemos que a utilização de acentos provocou
falha no nosso teste.

Para compreender o problema precisamos entender sobre
*((codificação))* de arquivos. Enquanto caracteres ASCII são
facilmente codificados, pois cada carácter possui um único byte (que
corresponde ao tamanho de um `char`), outras codificações, como UTF-8,
podem possuir carácteres com tamanhos diferentes. Além disso, pode
existir mais de uma codificação para o mesmo carácter.

Por enquanto nós iremos utilizar o ((Algorítimo do Avestruz)) para
resolução de problemas: nós iremos ignorar o problema e continuar
nossa implementação ignorando o tratamento de acentos. Depois, quando
tivermos conhecimento suficiente para tratar este problema poderemos
voltar a ele.

TIP: Você conhecer mais sobre o *Algorítimo do Avestruz* em
http://pt.wikipedia.org/wiki/Algoritmo_do_avestruz.


==== Desfazer teste com acentos

Para manter nossos testes passando vamos manter o carácter `á` no
string `TRADUCAO_ESPERADA2`:

[source,c]
----
char* MENSAGEM_ORIGINAL2="Oh! Deus, será que o senhor se zangou";
char* TRADUCAO_ESPERADA2="Ih! Diis, sirá qii i sinhir si zingii";<1>
----
<1> Substituição do `í` por `á`. Por enquanto nosso programa não irá
    tratar acentos. 

==== Desfazer implementação de core que tratava acentos

Em seguida, precisamos remover de `traduzCaracterParaLinguaDoI` os
`case` com carácteres acentuados:

[source,c]
----
char traduzCaracterParaLinguaDoI(char original){
	char resposta;

	switch (original) {
	case 'a':
	case 'e':
	case 'i':
	case 'o':
	case 'u':
		resposta = 'i';
		break;
	case 'A':
	case 'E':
	case 'I':
	case 'O':
	case 'U':
		resposta = 'I';
		break;
	default:
		resposta = original;
	}

	return resposta;
}
----

Após atualizar a função, vamos re-executar os testes:

.Re-execução dos testes após remoção de tratamento de acentos
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
./lingua-do-i-test
....

Ótimo, como esperado, nossos testes estão passando novamente!

==== Mantendo registro de novas funcionalidades no TODO

Para não esquecer que temos uma dendência no projeto, vamos criar
um arquivo como nome `TODO.txt` que manterá registro de
atividades que gostaríamos de realizar no futuro:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/TODO.txt]

[source, c]
.Criação do arquivo TODO.txt
....
include::{local}/{etapa}/TODO.txt[]
....

TIP: A criação de um arquivo *TODO* possibilita comunicar para as demais
pessoas (envolvidas ou que irão se envolver no projeto) onde elas
podem contribuir para o projeto.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 11: Salvando conteúdo em arquivo
:etapa: etapa11

Além de traduzir mensagens nosso programa também precisa salvar seu
conteúdo em arquivo. Nesta etapa vamos atualizar nossa implementação
para possibilitar o salvamento.

==== Adicionar teste de salvamento de conteúdo

Mas uma vez, antes de iniciar a implementação da nossa funcionalidade
iremos escrever seu teste:

[source,c]
----
char* CONTEUDO_QUALQUER = "abracadabra";
void testSalvaConteudoEmArquivo(){
  FILE * arquivoDestino = criaArquivoTemporario(); <1>
  salvaConteudo(arquivoDestino, CONTEUDO_QUALQUER); <2>
  verificaConteudoFoiSalvo(arquivoDestino, CONTEUDO_QUALQUER); <3>

  fclose(arquivoDestino); <4>
}
----
<1> Criação de um arquivo temporário para o teste, o conteúdo do teste
    será escrito nele. Se estivéssemos utilizando um arquivo normal,
    deveríamos nos certificar de que o arquivo não existia antes, em
    decorrência de execuções anteriores. Arquivos temporários são bons
    para os testes pois quando fechados são automaticamente excluídos.
<2> Esta função será implementada no core, será responsável por salvar
    um string em um `FILE`.
<3> Função para verificar que o conteúdo escrito no arquivo
    corresponde ao conteúdo passado como parâmetro
    (`CONTEUDO_QUALQUER`).
<4> Fechamento do arquivo temporário.

Percebam que estamos definindo que a função `salvaConteudo` irá
receber um `FILE*` ao invés de um `char*`, correspondente ao nome do
arquivo, diferente de como fizemos com a função `lerConteudoDoArquivo`
(no <<src_primeiro_teste>>). Isto foi intencional, pois pretendemos, no
futuro, salvar o conteúdo também na saída padrão (que é do tipo
`FILE*`).  

==== Função para criar arquivo temporário

Precisamos criar a função responsável pela criação do arquivo
temporário que foi definida no teste:

[source,c]
.Função para criar arquivos temporários
----
FILE * criaArquivoTemporario(){
	return tmpfile(); <1>
}
----
<1> Neste função apenas invocamos a função `tmpfile()`.

NOTE: Decidimos criar a função `criaArquivoTemporario` apenas para
aumentar a legibilidade do código para os leitores em português. Na
prática, não haveria a necessidade de criá-la.

==== Verificando conteúdo salvo no arquivo

A outra função, para verificar que o conteúdo salvo
no arquivo corresponde ao que foi escrito nele, foi implementada
como a seguir:


[source, c]
.Função para verificar conteúdo salvo em arquivo
----
void verificaConteudoFoiSalvo( FILE* arquivo, 
    char* conteudo_esperado ){
  char* conteudo = lerConteudoDeArquivoArberto(arquivo); <1>
  assert( strcmp(conteudo, conteudo_esperado) == 0
    && "Conteúdo do arquivo não corresponde ao esperado");<2>
}
----
<1> A função `lerConteudoDeArquivoArberto` foi implementada em
    `lingua-do-i-core.c`, mas ainda não está visível aqui,
    precisaremos adicioná-la ao cabeçalho mais adiante.
<2> Código similar a `verificaConteudosSaoIguais`, mas com outra
    mensagem.

Percebam que na segunda linha, poderíamos ter invocado
`verificaConteudosSaoIguais(conteudo, conteudo_esperado)`, mas quando
esta função fosse falhar receberíamos a mesma mensagem das falhas
anteriores, então optamos por exibir uma nova mensagem: ``Conteúdo do
arquivo não corresponde ao esperado''.


==== Atualização do arquivo de cabeçalho do core

Sabemos que temos algumas alterações pendentes para serem realizadas
no arquivo de cabeçalho do core, vamos realizá-las agora:

[source,c]
.Atualização de lingua-do-i-core.h
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo); <1>
char* lerConteudoDeArquivoArberto(FILE* arquivo); <2>
----
<1> Principal função do teste, que desejamos implementar no core.
<2> Declaração de função já implementada em core mas que não estava
    visível externamente ao arquivo.

==== Implementação vazia para possibilitar teste falhar

Antes de compilar e executar o teste, precisamos ainda criar uma
implementação vazia de `salvaConteudo`:

[source,c]
.Implementação vazia em lingua-do-i-core.c
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo){
}
----

==== Verificando o teste falhando

Com a implementação da função realizada, vamos compilar os arquivos e
executar os testes:

.Compilação e execução dos testes
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o
lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:28: verificaConteudoFoiSalvo:
Assertion `strcmp(conteudo, conteudo_esperado) == 0 && "Conteúdo do
arquivo não corresponde ao esperado"' failed.
Abortado (imagem do núcleo gravada)
....

Como esperado, o teste falhou exatamente porque a função que deveria
escrever o conteúdo está vazia. Repare que a mensagem da falha
corresponde à mesma da verificação que adicionamos nesta etapa.

==== Fazendo o teste passar

Desta vez não há uma forma simples de fazer o teste passar, precisamos
realmente escrever o conteúdo no arquivo para que o teste passe.

Implementamos a função `salvaConteudo` da seguinte forma:

[source,c]
.Implementação para escrever conteúdo no arquivo
----
void salvaConteudo(FILE* arquivoDestino, char* conteudo){
  fprintf(arquivoDestino, "%s", conteudo);
}
----

TIP: A função <<fprintf>> é similar a <<printf>>, a única diferença é
que `printf` escreve sempre na saída padrão, enquanto que `fprintf`
recebe como parâmetro qual o arquivo (`FILE*`) onde será escrito o
conteúdo.

Após a implementação, vamos verificar os testes:

.Execução dos testes
....
$ make clean && make && ./lingua-do-i-test 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
....

Ótimo, nossos testes estão passando novamente!

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 12: Determinando entrada do aplicativo

:etapa: etapa12

Nesta etapa vamos definir como o programa irá determinar qual a
entrada será processada, se utilizará a entrada padrão ou a partir de
um arquivo.

Nesta funcionalidade, caso o aplicativo seja invocado sem nenhum
parâmetro, ele irá ler da entrada padrão, caso seja especificado o
nome de um arquivo, ele será utilizado.

.Invocando sem parâmetro: ler da entrada padrão
....
lingua-do-i 
....

.Invocando com parâmetro: ler do arquivo
....
lingua-do-i meu-arquivo-de-entrada.txt
....


IMPORTANT: Lembre-se que estamos construindo uma aplicação, embora
estivemos implementando vários testes, aos poucos as funcionalidades
do nosso programa estão sendo implementadas em `lingua-do-i-core.c`.
Mais adiante iremos alterar `lingua-do-i.c` para invocar as funções do
core.

==== Testes para especificar a entrada

No código a seguir estão definidos 3 testes, que utilizam os
parâmetros passados pelo sistema operacional à função <<sec_main>>,
para determinar a entrada:

[source,c]
.Testes para determinar a entrada do programa
----
int ARGC_SEM_PARAMETROS  = 1;
const char* ARGV_SEM_PARAMETROS[] = {"lingua-do-i"};
void testDefinirEntradaPadrao(){
	FILE* entrada = determinaEntrada(ARGC_SEM_PARAMETROS,
		ARGV_SEM_PARAMETROS);
	verificaEntradaFoiEntradaPadrao(entrada);
}

int ARGC_COM_1_PARAMETRO = 2;
const char* ARGV_ARQUIVO_VALIDO[] =
	{"lingua-do-i", "musica-trecho.txt"};
const char* ARGV_ARQUIVO_INEXISTENTE[] =
	{"lingua-do-i", "inexistente.xyz"};
void testDefinirEntradaDeArquivo(){
	FILE* entrada = determinaEntrada(ARGC_COM_1_PARAMETRO,
		ARGV_ARQUIVO_VALIDO);
	verificaEntradaFoiArquivoValido(entrada);
}

void testDefinirEntradaDeArquivoInexistente(){
	FILE* entrada = determinaEntrada(ARGC_COM_1_PARAMETRO,
		ARGV_ARQUIVO_INEXISTENTE);
	verificaEntradaFoiInvalida(entrada);
}
----

Os três testes estão invocando a função `determinaEntrada`, que ainda
será implementada no core, mas que terá a responsabilidade de
determinar a entrada do aplicativo a partir dos parâmetros passados à
função <<sec_main>>:

testDefinirEntradaPadrao::
Neste teste estamos definindo que se o programa for executado sem
nenhum parâmetro, ele irá ler da entrada padrão.

testDefinirEntradaDeArquivo::
Caso o programa seja invocado passando o nome do arquivo, ele será
utilizado como entrada.

testDefinirEntradaDeArquivoInexistente::
Caso seja passando o nome do arquivo, mas ele não exista, então o
programa não poderá processar a entrada.

TIP: Perceba como os nomes das funções facilitam na compreenção do
código. É preferível que você crie várias funções pequenas com
responsabilidades bem definidas do que uma poucas funções com muitas
responsabilidades.

Por último, também é necessário invocá-los a partir do main:

[source,c]
.Invocando os testes a partir do main
----
int main(void) {
	...
	testDefinirEntradaPadrao();
	testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
----

==== Fazendo os testes falharem

Uma vez definido os testes, nosso próximo passo é fazê-los compilarem
e falharem.

Para fazer os testes compilarem precisamos da ajuda do compilador,
utilizaremos as notificações de problemas de compilação para
descobrir o próximo passo:

.Invocando o compilador para descobrir o próximo passo
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaPadrao’:
lingua-do-i-test.c:54:2: aviso: implicit declaration of function ‘determinaEntrada’ [-Wimplicit-function-declaration]
...
....

O compilador nos informou que a  função `determinaEntrada` ainda não
existe, precisamos defini-la no cabeçalho e criá-la no core:

[source,c]
.Adicionando determinaEntrada em lingua-do-i-core.h
----
FILE* determinaEntrada(int argc, const char* argv[]);
----

Em seguida precisamos criar a função no core:

[source,c]
.Implementando determinaEntrada no core
----
FILE* determinaEntrada(int argc, const char* argv[]){
	return NULL;
}
----

Vamos invocar a compilação novamente para ter uma sugestão do próximo
passo:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaPadrao’:
lingua-do-i-test.c:56:2: aviso: implicit declaration of function ‘verificaEntradaFoiEntradaPadrao’ [-Wimplicit-function-declaration]
...
....

Descobrimos que o próximo passo é criar a função
`verificaEntradaFoiEntradaPadrao`:

[source,c]
----
void verificaEntradaFoiEntradaPadrao(FILE* entrada){
	assert(entrada == stdin && 
	    "Entrada deveria ser Entrada Padrão");
}
----

Compilando novamente para descobrir o próximo passo:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaDeArquivo’:
lingua-do-i-test.c:69:2: aviso: implicit declaration of function ‘verificaEntradaFoiArquivoValido’ [-Wimplicit-function-declaration]
...
....

O erro anterior foi corrigido, agora o compilador nos informa que
precisamos implementar a função `verificaEntradaFoiArquivoValido`:

[source,c]
.Implementação de verificaEntradaFoiArquivoValido no teste
----
void verificaEntradaFoiArquivoValido(FILE* entrada){
	assert(entrada != NULL && entrada!= stdin &&
		"Entrada deveria ser um arquivo válido");<1>
}
----

Mais uma vez, compilando para descobrir o próximo passo:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testDefinirEntradaDeArquivoInexistente’:
lingua-do-i-test.c:80:2: aviso: implicit declaration of function ‘verificaEntradaFoiInvalida’ [-Wimplicit-function-declaration]
...
....

Novamente, precisamos implementar a função `verificaEntradaFoiInvalida`:

[source,c]
----
void verificaEntradaFoiInvalida(FILE* entrada){
	assert(entrada == NULL && "Entrada deve ser inválida");
}
----

Compilando para descobrir o próximo passo:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:52: verificaEntradaFoiEntradaPadrao: Assertion `entrada == stdin && "Entrada deveria ser Entrada Padrão"' failed.
make: *** [test_all] Abortado (arquivo core criado)
...
....

Ótimo! O código já está compilando e nosso primeiro teste está
falhando. 

==== Certificando-se que todos os novos testes estão falhando

Para verificar os outros testes falhando, basta comentar a
linha de invocação do teste na função `main`:

[source,c]
.Comentando teste para verificar que os demais estão falhando
----
int main(void) {
	testLerConteudoDoArquivo();
	testSalvaConteudoEmArquivo();
	testTraducaoParaLinguaDoI();

	//testDefinirEntradaPadrao();
	testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
----

Verificando o próximo teste falhando:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:57: verificaEntradaFoiArquivoValido: Assertion `entrada != ((void *)0) && entrada!= stdin && "Entrada deveria ser um arquivo válido"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....


Mais um teste falhando, falta apenas verificar o último.

[source,c]
----
int main(void) {
	testLerConteudoDoArquivo();
	testSalvaConteudoEmArquivo();
	testTraducaoParaLinguaDoI();

	//testDefinirEntradaPadrao();
	//testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	return EXIT_SUCCESS;
}
--------

Tentando verificar o último teste falhando:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

O último teste não está falhando. Verificar que o teste está falhando
é uma etapa muito importantefootnote:[Para saber mais sobre os testes
falhando consulte
http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd.], vamos
modificar a implementação de `determinaEntrada` para garantir isso:

[source,c]
.Modificação em core para todos os testes falharem
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* resultadoParaFalhar;
	if (argc == 1){
		resultadoParaFalhar = stdout;
	}else{
		resultadoParaFalhar = stdin;
	}
	return resultadoParaFalhar;
}
----

Vamos re-executar o teste:

....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:62: verificaEntradaFoiInvalida: Assertion `entrada == ((void *)0) && "Entrada deve ser inválida"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Após esta modificação todos os testes falham, estamos prontos para
avançar para a próxima etapa.

NOTE: Perceba que todas as mensagens de falha dos testes foram
diferentes, para ficar evidente a causa da falha.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 13: Fazendo os testes de entrada passarem
:etapa: etapa13


==== Fazendo os testes passarem

Antes de fazer o primeiro teste passar, vamos verificar o teste falhando
novamente:

.Verificando teste da entrada padrão falhando
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:53: verificaEntradaFoiEntradaPadrao: Assertion `entrada == stdin && "Entrada deveria ser Entrada Padrão"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Para o teste passar, precisamos retornar `stdin` quando o aplicativo
for invocado sem parâmetros:

[source, c]
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* entrada;
	if (argc == 1){
		entrada = stdin; <1>
	}else{
		entrada = stdin;
	}
	return entrada;
}
----
<1> Quando `argc == 1`, então não há nenhum parâmetro e devemos
    retornar a entrada padrão. 

Após esta modificação, vamos executar os testes novamente:

.Re-execução dos testes
....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:58: verificaEntradaFoiArquivoValido: Assertion `entrada != ((void *)0) && entrada!= stdin && "Entrada deveria ser um arquivo válido"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Ótimo, nosso primeiro teste passou, e a falha do segundo foi
apresentada. 

O próximo passo será fazer o segundo teste passar. Este teste espera
que caso seja passado o nome do arquivo como parâmetro, então a
entrada deve utilizá-lo para leitura:

[source,c]
.Ajuste para fazer o segundo teste passar
----
FILE* determinaEntrada(int argc, const char* argv[]){
	FILE* entrada;
	if (argc == 1){
		entrada = stdin;
	}else{
		entrada = fopen(argv[1], "r"); <1>
	}
	return entrada;
}
----
<1> Utiliza <<fopen>> para abrir arquivo para leitura, utilizando o
    nome do arquivo passado como parâmetro.

Após esta modificação vamos re-executar os testes:

....
$ make clean && make lingua-do-i-test && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Com esta última modificação todos os nossos testes estão passando! 

Na próxima etapa iremos unir a implementação de core no `main()` para
gerar o aplicativo capaz de traduzir para língua do i.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

=== Etapa 14: Implementando aplicaçaõ da lingua-do-i
:etapa: etapa14

==== Construindo o main

Agora que já possuímos várias funções implementadas vamos
incorporá-las ao `main` da aplicação.

[source, c]
----
#include <stdio.h>
#include <stdlib.h>
#include "lingua-do-i-core.h" <1>

int main(int argc, const char* argv[]) {<2>

	FILE* entrada = determinaEntrada(argc, argv);

	if (entrada){<3>
		char* conteudo=lerConteudoDeArquivoArberto(entrada);<4>
		char* mensagem = traduzParaLingaDoI(conteudo);<4>
		salvaConteudo(stdout, mensagem);<5>
	}else{
		fprintf(stderr, "Problema ao abrir arquivo: %s\n",
				argv[1]);<6>
		exit(EXIT_FAILURE);<6>
	}

	return EXIT_SUCCESS;
}
----

<1> Nosso primeiro passo é incluir o cabeçalho de core, para poder
    utilizar as funções definidas lá.
<2> Atualizamos o cabeçalho do `main`, adicionando os parâmetros que
    serão atribuídos pelo sistema operacional ao invocar a aplicação.
<3> Em C é comum a checagem de parâmetros desta forma, caso o
    parâmetro seja diferente de zero ou `NULL`, então é o valor válido.
<4> Ler conteúdo da entrada e traduz para língua do i
<5> Salva a mensagem traduzida na saída padrão. O usuário poderá
    redirecionar para um arquivo se desejar.
<6> Caso o arquivo não exista, a aplicação finaliza com mensagem na
    *saída de erro*.

A seguir você pode conferir a compilação com sucesso da aplicação:

.Compilação de lingua-do-i
....
$ make clean && make && make test_all
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....



==== Executando lingua-do-i

Primeiro vamos testar a tradução lendo de um arquivo passado como
parâmetro:

.Lendo de arquivo passado como parâmetro
....
$ ./lingua-do-i musica-trecho.txt 
Ih! Diis, pirdii isti pibri ciitidi
....

Em seguida, vamos testar ler da entrada padrão, direcionada de um
arquivo:

....
$ ./lingua-do-i < musica-trecho.txt 
Ih! Diis, pirdii isti pibri ciitidi
....

Ainda faltamos testar se foi passado um arquivo que não existe:

....
$ ./lingua-do-i arquivo-que-nao-existe.txt
Problema ao abrir arquivo: arquivo-que-nao-existe.txt
....

Nosso aplicativo foi capaz de ler de um arquivo, passado como
parâmetro ou sendo direcionado pela entrada padrão. Mas será que ele é
capaz de ler a partir da entrada padrão sem ser direcionado de um
arquivo? Vamos fazer o teste!

Tentando ler da entrada padrão:
....
$ cat musica-trecho.txt | ./lingua-do-i
....

NOTE: O comando `cat`, disponível no Linux, ler o conteúdo de um arquivo
e o imprime na saída padrão. Ele é equivalente ao comando `type` no
Windows.

O resultado esperado não foi satisfatório, ele deveria ser capaz de
ler da entrada padrão, o que está errado com a nossa implementação?
Vamos analisá-la na próxima etapa.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 15: Processando entrada por fluxo

:etapa: etapa15

Nossa aplicação não foi capaz de traduzir uma mensagem ao recebê-la
por um fluxo na entrada padrão.

Nós sabemos que a <<src_funcao_lerTamanhoDoArquivo>> vai ao final do
arquivo, depois retorna para o início. Mas isto não é possível quando
estamos processando fluxos.

Para possibilitar traduzir através de fluxos, vamos iniciar escrevendo
um teste para isso.


==== Incluindo teste para tradução de fluxo

Neste teste, estamos desejando implementar uma função
`traduzFluxoDeEntradaNaSaida` que irá traduzir a mensagem de entrada e
salvar sua tradução na saída.  

[source,c]
.Teste de tradução de fluxo
----
char* MUSICA_COMPLETA = "musica-completa.txt";
char* MUSICA_COMPLETA_TRAUDIZADA = "musica-completa-traduzida.txt";
void testTraduzFluxoDeEntrada(){
	FILE* entrada = fopen(MUSICA_COMPLETA,"r");
	FILE* saida = tmpfile();
	traduzFluxoDeEntradaNaSaida(entrada,saida);

	verificaMusicaFoiTraduzidaCorretamenteNaSaida(saida,
			MUSICA_COMPLETA_TRAUDIZADA);

	fclose(entrada);
	fclose(saida);
}
----

Para garantir a tradução correta, criamos um arquivo temporário para
servir como saída da função, em seguida,
`verificaMusicaFoiTraduzidaCorretamenteNaSaida` irá ler o conteúdo
escrito em `saida` e comparar com o conteúdo do arquivo
`MUSICA_COMPLETA_TRAUDIZADA`.

A função para verificar a tradução foi implementada da seguinte forma:

[source,c]
----
void verificaMusicaFoiTraduzidaCorretamenteNaSaida(
    FILE* fluxo, char* arquivoComTraducaoCorreta){
  
  rewind(fluxo); // volta para ler do início do fluxo
  char* conteudo=lerConteudoDeArquivoArberto(fluxo);
  char* traducao=lerConteudoDoArquivo(arquivoComTraducaoCorreta);

  assert( strcmp(conteudo, traducao) == 0
      && "Arquivo deve ser traduzido corretamente");
}
----

==== Salvando a letra da música e sua tradução

Para execução do teste também é preciso criar os arquivos com a música
e a tradução:

.Música completa
....
Oh! Deus, perdoe este pobre coitado
Que de joelhos rezou um bocado
Pedindo pra chuva cair sem parar

(...)

Desculpe eu pedir a toda hora pra chegar o inverno
Desculpe eu pedir para acabar com o inferno
Que sempre queimou o meu Ceará
....

.Música traduzida
....
Ih! Diis, pirdii isti pibri ciitidi
Qii di jiilhis rizii im bicidi
Pidindi pri chivi ciir sim pirir

(...)

Discilpi ii pidir i tidi hiri pri chigir i invirni
Discilpi ii pidir piri icibir cim i infirni
Qii simpri qiiimii i mii Ciirá
....

NOTE: Ainda não estamos tratando vogais acentuadas, portanto o arquivo
traduzido ainda possui as vogais acentuadas.

==== Fazendo o teste falhar

Vamos invocar o compilador diversas vezes para descobrir os próximos
passos até o teste falhar:

.Invocando o compilador
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
lingua-do-i-test.c: Na função ‘testTraduzFluxoDeEntrada’:
lingua-do-i-test.c:107:2: aviso: implicit declaration of function ‘traduzFluxoDeEntradaNaSaida’ [-Wimplicit-function-declaration]
/tmp/ccPNDB7P.o: In function `testTraduzFluxoDeEntrada':
/home/santana/livro/capitulos/code/lingua-do-i/etapa15/src/lingua-do-i-test.c:107: undefined reference to `traduzFluxoDeEntradaNaSaida'
collect2: ld returned 1 exit status
make: ** [lingua-do-i-test] Erro 1
....

O compilador nos avisou que precisamos criar a função
`traduzFluxoDeEntradaNaSaida`:

[source,c]
.Inclusão de traduzFluxoDeEntradaNaSaida no cabeçalho
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida);
----

[source,c]
.Criando função traduzFluxoDeEntradaNaSaida vazia no core
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
}
----

.Compilando e executando os testes
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:98: verificaMusicaFoiTraduzidaCorretamenteNaSaida: Assertion `strcmp(conteudo, traducao) == 0 && "Arquivo deve ser traduzido corretamente"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Ótimo, nosso teste está falhando!

==== Fazendo o teste passar
Uma vez que nosso teste está falhando, o próximo passo é fazê-lo
passar, com o esforço mínimo. Para isso, vamos atualizar a função
`traduzFluxoDeEntradaNaSaida` para escrever na saída o valor que
esperamos:

[source,c]
.Fazendo o teste passar com esforço mínimo
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
	char* traducao = lerConteudoDoArquivo("musica-completa-traduzida.txt");
	int tamanhoDaTraducao = strlen(traducao);
	fwrite(traducao,1,tamanhoDaTraducao,saida);
}
----

Esta implementação é temporária, servirá apenas para verificarmos o
teste passando:

.Verificação do teste passando
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Ótimo! Nossos testes estão passando novamente. Agora precisamos
substituir a implementação da função por outra que continue passando.

==== Implementando tradução por fluxo

Quando estamos tratando um fluxo, precisamos lê-lo por partes. Só
podemos ler uma outra parte após tratar a anterior. Em nossa
implementação, decidimos dividir o fluxo por linhas:

[source,c]
.Tradução do fluxo por linhas
----
void traduzFluxoDeEntradaNaSaida(FILE* entrada, FILE* saida){
	bool chegouNoFinalDoArquivo = false;

	while (!chegouNoFinalDoArquivo){
		char* linha = lerLinhaDaEntrada(entrada);
		if (tentouLerAposFinalDoArquivo(linha)) {
			chegouNoFinalDoArquivo = true;
		} else {
			char* traducao = traduzParaLingaDoI(linha);
			salvaConteudoNaSaida(traducao, saida);
		}
	}
}
----

A lógica da função `traduzFluxoDeEntradaNaSaida` consiste em ler a
entrada por linhas. A função entra em loop enquanto não chegou ao
final do arquivo: lendo uma linha da entrada por vez, traduz e em
seguida salva a tradução na saída. A condição de parada do loop
só ocorre quando última linha foi traduzida e o final do arquivo foi
atingido.

A condição de parada é implementada através da variável
`chegouNoFinalDoArquivo`, que inicia com valor `false` e só será
modificada quando `tentouLerAposFinalDoArquivo` retornar verdadeiro.

A função `lerLinhaDaEntrada` será responsável por ler do fluxo de
entrada uma linha. E `salvaConteudoNaSaida` será responsável
por salvar a tradução na saída.

Estas três funções ainda não existem, precisaremos implementá-las a
seguir.

===== Lendo conteúdo da entrada com fgets

Vamos iniciar a implementação com a função `lerLinhaDaEntrada`,
responsável por ler uma linha da entrada:

(((fgets)))(((calloc)))

[source,c]
----
int TAMANHO_MAXIMO_DA_LINHA = 2048; <1>
char* lerLinhaDaEntrada(FILE* entrada){
	char* linha = calloc(1, TAMANHO_MAXIMO_DA_LINHA); <2>
	return fgets(linha, TAMANHO_MAXIMO_DA_LINHA, entrada); <3>
}
----
<1> Definindo tamanho máximo de leitura de linha (buffer).
<2> Alocando espaço suficiente para caber uma linha.
<3> Lendo da entrada e salvando o conteúdo lido no buffer (linha).

Para compreender esta função é preciso entender que <<fgets>> irá ler
até:

1. Encontrar o fim de linha, 
2. Ou até chegar ao final do fluxo 
3. Ou até ler a quantidade de caracteres referenciada por
`TAMANHO_MAXIMO_DA_LINHA`.

[[sec_fgets_feof]]
===== Sobre as funções fgets e feof

O propósito da função <<feof>> é indicar se em leituras anteriores o
final do arquivo foi _atingido_. Para que isto ocorra, as funções de
leitura, como `fgets`, devem registrar na estrutura `FILE` quando
detectarem o final do fluxo.

A função <<fgets>> só poderá indicar que chegou ao final do arquivo
quando ela _atingir_ o final do arquivo. A <<fig_fgets>> ilustra o
funcionamento da função `fgets`, estamos evidenciando dois casos:

Quando última linha não termina com o carácter de final de linha::
Neste caso, os bytes são lidos até quando tentou ler o próximo byte e
identificou que chegou no final do arquivo. Neste momento a função irá
retornar todos os bytes lidos e registrar que o final do arquivo foi
_atingido_. Chamadas subsequentes a `feof` saberão do ocorrido.

Quando a última linha termina com carácter final de linha::
A função `fgets` irá retornar todos os carácteres da última linha,
inclusive o `\n`. Ao encontrar o final de linha, a leitura da linha é
finalizada. Não houve nenhum registo de que se chegou ao final do
arquivo. Somente ao tentar ler mais uma linha, é que a função
`fgets` irá perceber que chegou ao final do arquivo e irá registrar o
ocorrido. Diferente do caso anterior, o retorno da função será `NULL`,
indicando que não houve nenhum conteúdo lido.

[[fig_fgets]]
.Ilustração de leitura com fgets
image::images/lingua-do-i/fgets.eps[scaledwidth="80%"]

===== Condição de parada tentouLerAposFinalDoArquivo

Para garantir que todas as linhas lidas sejam traduzidas, não basta
ler até atingir o final do arquivo, precisamos nos certificar que
mesmo atingido o final, a última linha seja traduzida. Portanto, a
condição de parada será ler até que `fgets` retorne null:

[source,c]
----
bool tentouLerAposFinalDoArquivo(char* linha){
	return linha == NULL;
}
----


////
E sobre o tamanho máximo da linha? E se a linha for maior do
que este tamanho máximo? Vamos supor que o tamanho máximo fosse 10
caracteres, e a linha tivesse 15 caracteres. Na primeira chamada a
este método seriam lidos os 10 primeiros caracteres, traduzidos e
processados. A próxima chamada iria ler os caracteres restante até o
final da linha. 
////

===== Salvando o conteúdo com a função fwrite

Finalmente, precisamos salvar o conteúdo traduzido na saída:

[source,c]
.Escrevendo conteúdo na saída
----
void salvaConteudoNaSaida(char* conteudo, FILE* saida){
	int tamanhoDaMensagem = strlen(conteudo);
	fwrite(conteudo,1,tamanhoDaMensagem,saida);
}
----

==== Verificando que os testes continuam passando

Após estas atualizações, vamos verificar se nossos testes continuam
passando:

.Verificando os testes passando após as modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....

Ótimo, nossos testes estão passando novamente!

==== Atualizando aplicação para processar fluxos

Após os testes passarem, nosso próximo passo será a atualização da
aplicação para utilizar a nova implementação:

[source,c]
.Atualizando main em lingua-do-i.c para processar fluxos
----
int main(int argc, const char* argv[]) {
	FILE* entrada = determinaEntrada(argc, argv);
	if (entrada){
		traduzFluxoDeEntradaNaSaida(entrada, stdout);
	}else{
		fprintf(stderr, "Problema ao abrir arquivo: %s\n",
				argv[1]);
		exit(EXIT_FAILURE);
	}
	return EXIT_SUCCESS;
}
----

Após atualização, vamos compilar a aplicação:

.Compilando a aplicação
....
$ make clean && make lingua-do-i
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i.c lingua-do-i-core.c -o lingua-do-i
....

Verificando que a aplicação está processando a entrada por fluxo:

.Utilizando aplicação para traduzir fluxo
....
$ cat musica-trecho.txt | ./lingua-do-i
Ih! Diis, pirdii isti pibri ciitidi
....

Ótimo! Nossa aplicação agora é capaz de processar o fluxo de entrada
também.

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]


=== Etapa 16: Tratando acentos

:etapa: etapa16

Revendo nosso arquivo `TODO.txt`, lembramos que ainda está faltando
processar mensagens com acentos.

==== Fazendo o teste de tradução de vogais acentuadas falhar

Nós temos dois testes relacionados à tradução para lingua do i. Por
enquanto eles foram implementados para não traduzirem vogais
acentuadas e estão passando deste jeito. Para fazê-los
falharem nós precisaremos atualizá-los da seguinte forma: 

`testTraducaoParaLinguaDoI`:: Atualizar o string
`TRADUCAO_ESPERADA2`, substituindo `á` por `í`:
+
[source,c]
----
// ANTES
char* TRADUCAO_ESPERADA2= "Ih! Diis, sirá qii i sinhir si zingii";
// DEPOIS
char* TRADUCAO_ESPERADA2= "Ih! Diis, sirí qii i sinhir si zingii";
----

`testTraduzFluxoDeEntrada`:: Neste teste utilizamos o arquivo
`musica-completa-traduzida.txt` que contém o resultado esperado da
tradução. Você pode encontrar o arquivo referido já traduzido na pasta
do código desta etapa: 
{online}/etapa16/src/musica-completa-traduzida.txt 


Após estes modificações, executamos os testes e verificamos que
primeira falha está relacionada ao nosso primeiro teste, devido
a nossa alteração em `TRADUCAO_ESPERADA2`.

.Rexecutando os testes após as modifições com vogais acentuadas
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....


==== Entendendo o que é necessário para fazer o teste passar

Para fazer o teste passar, precisamos transformar ``á'' em ``í''.
Sabemos até agora que estes carácteres são representados com mais de
um byte. Vamos verificar sua representação em decimal:

.Utilizando comando od para ver representação dos caracteres
....
$ echo áéíóú | od -t d1
0000000  -61  -95  -61  -87  -61  -83  -61  -77  -61  -70   10
0000013
....

TIP: O comando `od`, disponível no Linux possui várias opções para
exibição de conteúdos binários. Neste caso estamos utilizando para
imprimir o valor de um byte com sinal, que equivale ao valor de
`signed char`.

Descobrimos que todos estes carácteres possuem dois bytes, onde o
primeiro tem valor `-61` e o segundo depende da vogal utilizada,
confira as representações na tabela a seguir:

[[tab_acento_agudo]]
[options="header",cols="^m,^m,^m"]
.Representação de vogais acentuados em UTF-8
|====
| Carácter | Primeiro Byte | Segundo Byte
| á | -61 | -95
| é | -61 | -87
| í | -61 | -83
| ó | -61 | -77
| ú | -61 | -70
|====

NOTE: O que precisamos fazer é implementar uma tradução que
identifique dois bytes consecutivos desta tabela e escreva na saída os
dois bytes do carácter `í`.

==== Fazendo o primeiro teste de tradução acentuada passar

Decidimos modificar a função `traduzParaLingaDoI`, atualmente
responsável por traduzir uma linha para a língua do i:

[source,c]
----
char* traduzParaLingaDoI(char* mensagemOriginal){
	int tamanhoDaMensagem = strlen(mensagemOriginal);
	char* traducao = calloc(1, tamanhoDaMensagem+1);

	for(int i=0; i<tamanhoDaMensagem; i++){
		char caracterDaMensagemOriginal = mensagemOriginal[i];
		if (podeSerVogalAcentuada(caracterDaMensagemOriginal)){ <1>
			int incremento = traduzCaracteresAcentuados(
					mensagemOriginal,i,traducao);<2>
			i+=incremento;<3>
		}else{ <1>
			traducao[i] = traduzCaracterParaLinguaDoI(<1>
				caracterDaMensagemOriginal);<1>
		}
	}
	return traducao;
}
----
<1> Nossa primeira modificação consiste em verificar se o primeiro
    byte lido corresponde ao início de uma vogal acentuada
    (`podeSerVogalAcentuada`). Se ele *não* for, então seguirá o fluxo
    normal, sendo traduzida pela função que traduz carácteres de um
    byte (`traduzCaracterParaLinguaDoI`), e adicionada ao String que
    corresponde à tradução. *Ainda precisamos criar a função
    `podeSerVogalAcentuada`*.
<2> Caso o primeiro byte lido seja o início de vogal acentuada,
    chamaremos a função `traduzCaracteresAcentuados` que deverá ler os
    bytes restantes necessários para representar o carácter e
    salvá-los na posição indicada por `i` no String `traducao`.
    Teoricamente um carácter acentuado poderia possuir mais de 2
    bytes, portanto esta função precisará retornar um incremento para ser
    utilizado em `i`, para garantir a consistência da posição de
    leitura. *A função `traduzCaracteresAcentuados` ainda não existe*,
    será criada mais adiante.
<3> Atualizamos o valor de `i` com o incremento necessário. É
    importante perceber que no comando `for`, a variável já é
    incrementada (`i++`), portanto não precisamos incrementá-la se
    apenas um byte for lido em `traduzCaracteresAcentuados`.

TIP: Certifique-se de ter entendido o código apresentado antes de
continuar.

Dando sequência, vamos criar as funções que desejamos utilizar,
iniciaremos com `podeSerVogalAcentuada`:

[source,c]
----
bool podeSerVogalAcentuada(char caracterInicial){
	return caracterInicial == -61; <1>
}
----

<1> A implementação desta função é muito simples, conforme resumido na
    <<tab_acento_agudo>>, o primeiro byte de todas as vogais com
    acento agudo tem o valor `-61`. A função simplesmente compara o
    byte lido com este valor, retornando o resultado da comparação.

Em seguida, vamos implementar a última função que ficou faltando:

[source,c]
----
int traduzCaracteresAcentuados(char* mensagem, int i,
		char* traducao){
	int incremento;
	char primeiroByte = mensagem [i];
	char s = mensagem [i+1]; // segundo byte <1>

	assert (primeiroByte == -61); // prefixo dos acentos <2>
	traducao[i] = primeiroByte; // passa o primeiro byte <3>

	if (s==-95 or s==-87 or s==-77 or s==-70){//áéóú <4>
		traducao[i+1] = -83; // í <5>
	}else{
		traducao[i+1] = mensagem[i+1]; <6>
	}
	incremento = 1; <7>
	return incremento;
}
----

<1> Iniciamos a função buscando os valores dos dois primeiros bytes. É
    importante observar aqui os nomes das variáveis. A variável
    `primeiroByte` possui um nome bastante representativo, não há
    necessidade de comentários. Já o segundo byte lido, estamos
    nomeando-o apenas por `s`, para diminuir o tamanho do código. No
    entanto, estamos adicionando um comentário explicando qual o
    propósito desta variável, esta é uma boa prática!
<2> A função `assert` está indicando que o pré-requisito desta função
    é ser chamada quando o primeiro byte possuir o valor `-61`, caso
    contrário seu comportamento não está definido. Aqui o comentário
    mais uma vez é importante, sem ele o número em questão poderia ser
    considerado um Número Mágico.footnote:[Você pode saber mais sobre
    Número Mágico em informática no seguinte link:
    http://pt.wikipedia.org/wiki/Número_mágico_(informática)] Para
    utilização do `assert`, também foi necessário incluir no início do
    código: `#include <assert.h>`.
<3> `traducao[i]` corresponde a posição onde deveremos escrever a
    tradução do carácter lido. Neste trecho, escrevemos o primeiro 
    byte lido na posição correspondente.
<4> Neste `if` estamos comparando o segundo byte lido com o segundo byte
    dos carácteres `áéóú`, conforme indicado no comentário.
<5> Caso o segundo byte lido corresponda ao segundo byte dos
    carácteres indicados, sua tradução corresponderá ao segundo byte
    de `í`, que possui o valor `-83`. Salvamos a tradução na posição
    `traducao[i+1]`.
<6> Caso contrário, o segundo byte é escrito conforme lido. Este é o
    caso inclusive do carácter `í`, que sua tradução corresponde a ele
    mesmo.
<7> Por fim, retornamos `1` como incremento, indicando que só foi
    necessário ler um byte após o primeiro. Também seria possível
    implementar o retorno da seguinte forma: `return 1;`, mas a
    intenção não fica bem transmitida.

Após as alterações em `traduzCaracteresAcentuados`, vamos re-executar
os testes:

.Re-execução dos testes após modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:98: verificaMusicaFoiTraduzidaCorretamenteNaSaida: Assertion `strcmp(conteudo, traducao) == 0 && "Arquivo deve ser traduzido corretamente"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Perceba que a falha agora é outra, nosso primeiro testes passou! A
falha ocorre em `verificaMusicaFoiTraduzidaCorretamenteNaSaida` que
corresponde ao segundo teste, devido as atualizações que
fizemos no arquivo `musica-completa-traduzida.txt`. Isto significa que
nossa implementação conseguiu traduzir corretamente `á` para `í`. Mas
será que ela traduz também `é` para `í`? Nós esperamos que sim, mas
não temos nenhum teste comprovando isso. Vamos fazer isto a seguir.

==== Criando teste de tradução específico para vogais acentuadas

Vamos criar um novo teste com o propósito específico para traduzir
vogais acentuadas:

[source,c]
.Teste específico para vogais acentuadas
----
char* VOGAIS_ACENTUADAS= "áéíóúÁÉÍÓÚ-âêîôûÂÊÎÔÛ-àèìòùÀÈÌÒÙ";
char* ACENTOS_ESPERADOS= "íííííÍÍÍÍÍ-îîîîîÎÎÎÎÎ-ìììììÌÌÌÌÌ";
void testTraduzVogaisAcentuadas(){
	char* traducao = traduzParaLingaDoI(VOGAIS_ACENTUADAS);
	verificaConteudosSaoIguais(traducao, ACENTOS_ESPERADOS);
}
----

O teste é bastante simples, todas as vogais no String
`VOGAIS_ACENTUADAS` deverão ser traduzidas por suas correspondentes em
`ACENTOS_ESPERADOS`. Na última linha verificaremos se os conteúdos são
idênticos.

Um detalhe importante, é que este teste deve ser chamado antes
de `testTraduzFluxoDeEntrada`, que ainda está falhando na tradução da
música:

[source,c]
.Posição da evocação do teste testTraduzFluxoDeEntrada no main
----
int main(void) {
	testLerConteudoDoArquivo();
	testSalvaConteudoEmArquivo();
	testTraducaoParaLinguaDoI();

	testDefinirEntradaPadrao();
	testDefinirEntradaDeArquivo();
	testDefinirEntradaDeArquivoInexistente();

	testTraduzVogaisAcentuadas(); <1>
	testTraduzFluxoDeEntrada();

	return EXIT_SUCCESS;
}
----
<1> Precisa ser evocado antes de `testTraduzFluxoDeEntrada`.

Vamos executar os testes novamente, esperamos que a falha seja
diferente da anterior:

....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:11: verificaConteudosSaoIguais: Assertion `strcmp(conteudo, esperado) == 0 && "conteúdo deve ser igual ao esperado"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Ótimo! Como podemos ver, temos uma falha diferente devido a inclusão
do nosso novo teste. O próximo passo será fazer o teste passar.

==== Fazendo o teste específico das vogais acentuadas passar

Nós já temos toda a _infraestrutura_ necessária para tradução das
vogais acentuadas, precisamos apenas descobrir os bytes que
representam todas estas letras e atualizar a função
`traduzCaracteresAcentuados`.

Invocaremos o comando `od` novamente para descobrir os bytes dos
carácteres:

....
$ echo áéíóú ÁÉÍÓÚ âêîôû ÂÊÎÔÛ àèìòù ÀÈÌÒÙ | od -t d1
0000000  -61  -95  -61  -87  -61  -83  -61  -77  -61  -70   32  -61 -127  -61 -119  -61
0000020 -115  -61 -109  -61 -102   32  -61  -94  -61  -86  -61  -82  -61  -76  -61  -69
0000040   32  -61 -126  -61 -118  -61 -114  -61 -108  -61 -101   32  -61  -96  -61  -88
0000060  -61  -84  -61  -78  -61  -71   32  -61 -128  -61 -120  -61 -116  -61 -110  -61
0000100 -103   10
0000102
....

Sabendo que espaço corresponde ao carácter `32`, percebemos que todas
as nossas vogais começam com *o valor do primeiro byte igual a `-61`*.
Vamos construir outra tabela para auxiliar na tradução:

[[tab_vogais_acentuadas]]
[options="header",cols="^m,^m,^m,^m,^m,^m,^m,^m,^m,^m,^m,^m"]
.Representação das vogais acentuadas em UTF-8
|====
| Char | 2º Byte | Char | 2º Byte | Char | 2º Byte | Char | 2º Byte | Char | 2º Byte | Char | 2º Byte
| á | -95 | Á | -127 | â | -94 |Â | -126 |à | -96 |À | -128
| é | -87 | É | -119 | ê | -86 |Ê | -118 |è | -88 |È | -120
| í | -83 | Í | -115 | î | -82 |Î | -114 |ì | -84 |Ì | -116
| ó | -77 | Ó | -109 | ô | -76 |Ô | -108 |ò | -78 |Ò | -110
| ú | -70 | Ú | -102 | û | -69 |Û | -101 |ù | -71 |Ù | -103
|====

A atualização da implementação é trivial, basta comparar o segundo
byte do carácter com os valores da tabela, substituindo-o pelo segundo
byte da vogal i com o acento correspondente:

[source,c]
.Atualizando para tradução dos carácteres acentuados
----
int traduzCaracteresAcentuados(char* mensagem, int i,
		char* traducao){
	int incremento;
	char primeiroByte = mensagem [i];
	char s = mensagem [i+1]; // segundo byte

	assert (primeiroByte == -61); // prefixo dos acentos
	traducao[i] = primeiroByte; // passa o primeiro byte

	if (s==-94 or s==-86 or s==-76 or s==-69){//âêôû
		traducao[i+1] = -82; //î
	}else if (s==-95 or s==-87 or s==-77 or s==-70){//áéóú
		traducao[i+1] = -83; // í
	}else if (s==-96 or s==-88 or s==-78 or s==-71){//àèòù
		traducao[i+1] = -84; //ì
	}else if (s==-126 or s==-118 or s==-108 or s==-101){//ÂÊÔÛ
		traducao[i+1] = -114; //Î
	}else if (s==-127 or s==-119 or s==-109 or s==-102){//ÁÉÓÚ
		traducao[i+1] = -115; //Í
	}else if (s==-128 or s==-120 or s==-110 or s==-103){//ÀÈÒÙ
		traducao[i+1] = -116; //Ì
	}else{
		traducao[i+1] = mensagem[i+1];
	}
	incremento = 1;
	return incremento;
}
----

Após nossas modificações, vamos executar os testes novamente:

.Executando o teste após as modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
lingua-do-i-test: lingua-do-i-test.c:98: verificaMusicaFoiTraduzidaCorretamenteNaSaida: Assertion `strcmp(conteudo, traducao) == 0 && "Arquivo deve ser traduzido corretamente"' failed.
make: *** [test_all] Abortado (arquivo core criado)
....

Estranho! Nosso teste passou e a falha ocorrida foi na função
`verificaMusicaFoiTraduzidaCorretamenteNaSaida`. Mas o estranho é que
teoricamente, uma vez que nossa função de tradução estivesse corretada, ela
deveria traduzir a música também!

==== Fazendo o teste de tradução da música passar com os acentos

A causa da falha é mais fácil de ser encontrada quando sabemos depurar
um programa. Após uma depuração (não mostrada aqui), descobrimos que o
teste falhou pois o programa não conseguiu traduzir `ã` para `ĩ`.

Realmente, nosso programa não estava traduzindo os carácteres com `~`.
Vamos descobrir suas representações:

....
$ echo "ã ~e ĩ õ ũ  Ã ~E Ĩ Õ Ũ" | od -t d1
0000000  -61  -93   32  -31  -70  -67   32  -60  -87   32  -61  -75   32  -59  -87   32
0000020   32  -61 -125   32  -31  -70  -68   32  -60  -88   32  -61 -107   32  -59  -88
0000040   10
....

IMPORTANT: Infelizmente tivemos um problema técnico na impressão do
carácter `e` acentuado com o `~`, estaremos representando o carácter
acentuado através do prefixo `~`. Então `~e` e `~E` representam os
carácteres acentuados em minúsculo e maiúsculo, o equivalente com a
vogal `a` seriam: `ã` e `Ã`.

Desta vez, nos deparamos com uma novidade! Os carácteres `~e` e `~E` são
codificados com 3 bytes e também não começam com `-61`! Vamos
construir nossa tabela para resumir a representação dos carácteres:

.Representação de vogais com `~`
[options="header",cols="^m,^m,^m,^m"]
|====
| Carácter | Bytes       | Carácter | Bytes
| `ã`        | -61 -93     | `Ã` | -61 -125
| `~e`       | -31 -70 -67 | `~E` | -31 -70 -68
| `ĩ`        | -60 -87     | `Ĩ` | -60 -88
| `õ`        | -61 -75     | `Õ` | -61 -107
| `ũ`        | -59 -87     | `Ũ` | -58 -88
|====

Com a tabela em mãos, precisamos atualizar nossa função que detecta
uma possível vogal acentuada:

[source,c ]
.Atualização da detecção do primeiro byte de uma vogal acentuada
----
bool podeSerVogalAcentuada(char caracter) {
	return caracter == -61 or caracter == -31 or caracter == -60
			or caracter == -59;
}
----

Em seguida, atualizamos a regra de tradução na função
`traduzCaracteresAcentuados` da seguinte forma:

[source,c]
.Atualização da função para incluir tradução com tio
----
int traduzCaracteresAcentuados(char* mensagem, int i,
		char* traducao){
	int incremento = 1; // por padrão ler dois bytes
	char primeiroByte = mensagem [i];
	char s = mensagem [i+1]; // segundo byte

	assert (primeiroByte == -61); // prefixo dos acentos
	traducao[i] = primeiroByte; // passa o primeiro byte por padrão

	if (primeiroByte == -61){
		if (s==-94 or s==-86 or s==-76 or s==-69){//âêôû
			traducao[i+1] = -82; //î
		}else if (s==-95 or s==-87 or s==-77 or s==-70){//áéóú
			traducao[i+1] = -83; // í
		}else if (s==-96 or s==-88 or s==-78 or s==-71){//àèòù
			traducao[i+1] = -84; //ì
		}else if (s==-126 or s==-118 or s==-108 or s==-101){//ÂÊÔÛ
			traducao[i+1] = -114; //Î
		}else if (s==-127 or s==-119 or s==-109 or s==-102){//ÁÉÓÚ
			traducao[i+1] = -115; //Í
		}else if (s==-128 or s==-120 or s==-110 or s==-103){//ÀÈÒÙ
			traducao[i+1] = -116; //Ì
		}else if (s==-93 or s==-75){//ãõ
			traducao[i] = -60; //ĩ - substitui primeiro byte
			traducao[i+1] = -87; //ĩ
		}else{
			traducao[i+1] = mensagem[i+1];
		}
	}else if (primeiroByte == -31){
		char terceiro = mensagem[i+2];
		if (s == -70 and terceiro == -67){ // ẽ
			traducao[i] = -60; // ĩ
			traducao[i+1] = -87; // ĩ
			incremento = 2; // descartamos o terceiro byte
		}else{
			traducao[i] = primeiroByte;
			traducao[i+1] = s;
			incremento = 1;
		}
	}else if (primeiroByte == -59){
		if ( s == -87 ) { // ũ
			traducao[i] = -60; // ĩ
			traducao[i+1] = -87; // ĩ
		}else{
			traducao[i] = primeiroByte;
			traducao[i+1] = s;
		}
	}else{
		traducao[i] = primeiroByte;
		traducao[i+1] = s;
	}
	return incremento;
}
----

Nossa implementação ficou grande,footnote:[Alguns estilos de código
defendem que se o código de uma função não couber na tela, ela está
grande demais e deveria delegar responsabilidades para outras
funções.] mas vamos verificar se ela está correta executando os
testes:

.Executando os testes após as modificações
....
$ make clean && make lingua-do-i-test && make test_all 
rm -rf lingua-do-i lingua-do-i-test
gcc -Wall -g -std=c1x lingua-do-i-test.c lingua-do-i-core.c -o lingua-do-i-test
./lingua-do-i-test
....


Ótimo! Nossos testes estão passando novamente! Nosso programa está
traduzindo corretamente para língua do i!footnote:[Realmente, um
programa está correto até que alguém encontre um erro ou _bug_.]

==== Código da etapa

Você pode consultar o código final desta etapa nos seguintes
arquivos:

.Código fonte
{online}/{etapa}/src/lingua-do-i.c[{local}/{etapa}/src/lingua-do-i.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-test.c[{local}/{etapa}/src/lingua-do-i-test.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.c[{local}/{etapa}/src/lingua-do-i-core.c]

.Código fonte
{online}/{etapa}/src/lingua-do-i-core.h[{local}/{etapa}/src/lingua-do-i-core.h]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-trecho.txt]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-completa.txt]

.Código fonte
{online}/{etapa}/src/musica-trecho.txt[{local}/{etapa}/src/musica-completa-traduzida.txt]

.Código fonte
{online}/{etapa}/src/Makefile[{local}/{etapa}/src/Makefile]

////
Terminando arquivo com linha em branco
////

